---
// Componente principal del mapa de miner√≠a - Restaurado con funcionalidad completa

// Props del componente
interface Props {
  muroFilter?: string
  drawingMode?: boolean
  canchaId?: string
  dashboardMode?: boolean
  canchaIds?: string
}

const { muroFilter, drawingMode = false, canchaId, dashboardMode = false, canchaIds } = Astro.props
console.log('üèóÔ∏è MiningMap iniciado con:', { muroFilter, drawingMode, canchaId, dashboardMode, canchaIds })
---

<style>
  .map-container {
    position: relative;
    width: 100%;
    height: 100vh;
    max-width: 100%;
    margin: 0 auto;
    border-radius: 0;
    overflow: hidden;
  }

  #map {
    width: 100%;
    height: 100%;
  }
  
  .map-controls {
    position: absolute;
    top: 16px;
    right: 16px;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  
  .control-panel {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    padding: 16px;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    min-width: 200px;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  }
  
  .control-group {
    margin-bottom: 16px;
  }
  
  .control-group:last-child {
    margin-bottom: 0;
  }
  
  .control-label {
    display: block;
    margin-bottom: 8px;
    font-weight: 600;
    color: #374151;
    font-size: 13px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  .control-select {
    width: 100%;
    padding: 10px 12px;
    border: 1px solid #d1d5db;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 500;
    background: white;
    color: #374151;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  .control-select:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }

  .loading { 
    position: absolute; 
    z-index: 1001; 
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    padding: 24px 32px;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    font-weight: 500;
    color: #374151;
  }

  .error { 
    position: absolute; 
    z-index: 1001; 
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(135deg, #ef4444, #dc2626);
    color: white;
    padding: 12px 20px;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(239, 68, 68, 0.3);
    font-weight: 500;
    max-width: 400px;
    text-align: center;
  }
</style>

<div class="map-container" data-muro-filter={muroFilter || ''} data-drawing-mode={drawingMode.toString()} data-cancha-id={canchaId || ''} data-dashboard-mode={dashboardMode.toString()} data-cancha-ids={canchaIds || ''}>
  <div id="map"></div>
  
  <div class="map-controls">
    <div class="control-panel">
      <div class="control-group">
        <label class="control-label">Filtro de Muros</label>
        <select id="muro-filter" class="control-select">
          <option value="todos">Todos los Muros</option>
          <option value="MP">MP</option>
          <option value="MO">MO</option>
          <option value="ME">ME</option>
        </select>
      </div>
    </div>
  </div>
  
  <div id="loading" class="loading" style="display: none;">
    Cargando datos...
  </div>
  
  <div id="error" class="error" style="display: none;"></div>
</div>
  <div id="loading" class="loading" style="display:none;">Cargando mapa...</div>
  <div id="error" class="error" style="display:none;"></div>
</div>

<script>
  // Importar usando dynamic import para evitar problemas de m√≥dulos
  async function initMapbox() {
    try {
      const mapboxgl = await import('mapbox-gl');
      const { POLYGON_STYLES, convertGeometry, calculateBounds, utmToWgs84 } = await import('../utils/mapbox.js');
      const { GISDataManager, RasterManager } = await import('../utils/gis.js');

      let map;
      let gisManager;
      let mapBounds = null;

      const MAP_CONFIG = {
        center: [-70.7376, -33.1193],
        zoom: 15, // Zoom original - TODO: Expandir cuando ortomosaico est√© actualizado
        bounds: [
          [-70.762292, -33.136471],  // Bounds originales
          [-70.708471, -33.111063]   // TODO: Expandir ~30% cuando imagen est√© lista
        ]
      };

      const mapElement = document.getElementById('map');
      const loadingElement = document.getElementById('loading');
      const errorElement = document.getElementById('error');

      function setLoading(loading) {
        if (loadingElement) {
          loadingElement.style.display = loading ? 'block' : 'none';
        }
      }

      function showError(message) {
        if (errorElement) {
          errorElement.textContent = message;
          errorElement.style.display = 'block';
          setTimeout(() => { errorElement.style.display = 'none'; }, 5000);
        }
      }

      async function getMapboxToken() {
        try {
          const response = await fetch('/mapbox-gis/token.txt');
          if (!response.ok) {
            throw new Error(`Error ${response.status}: ${response.statusText}`);
          }
          const token = await response.text();
          const cleanToken = token.trim();
          
          // Validar que el token tenga el formato correcto
          if (!cleanToken.startsWith('pk.')) {
            throw new Error('Token de Mapbox inv√°lido - debe comenzar con "pk."');
          }
          
          console.log('üîê Token validado correctamente:', cleanToken.substring(0, 20) + '...');
          return cleanToken;
        } catch (error) {
          console.error('Error loading Mapbox token:', error);
          throw new Error('No se pudo cargar el token de Mapbox: ' + error.message);
        }
      }

      async function initializeMap() {
        try {
          setLoading(true);
          
          // Verificar si estamos en modo de dibujo y obtener canchaId
          const mapContainer = document.querySelector('.map-container');
          const isDrawingMode = mapContainer?.getAttribute('data-drawing-mode') === 'true';
          const canchaId = mapContainer?.getAttribute('data-cancha-id');
          console.log('üé® Modo de dibujo activo:', isDrawingMode);
          console.log('üè∑Ô∏è Cancha ID:', canchaId);
          
          // CR√çTICO: Establecer el token ANTES de crear el mapa
          const token = await getMapboxToken();
          console.log('üîê Token de Mapbox obtenido:', token ? 'S√≠' : 'No');
          console.log('üîë Token completo:', token);
          
          // Establecer el token en mapboxgl ANTES de crear el mapa
          mapboxgl.accessToken = token;
          
          // Verificar que el token se estableci√≥ correctamente
          console.log('‚úÖ Token establecido en mapboxgl:', mapboxgl.accessToken);

          map = new mapboxgl.Map({
            container: 'map',
            style: { 
              version: 8, 
              sources: {}, 
              layers: [ 
                { 
                  id: 'background', 
                  type: 'background', 
                  paint: { 'background-color': '#f0f0f0' } // Fondo gris neutro
                } 
              ] 
            },
            center: MAP_CONFIG.center,
            zoom: MAP_CONFIG.zoom,
            maxBounds: MAP_CONFIG.bounds,
            accessToken: token // Tambi√©n pasar expl√≠citamente el token
          });

          map.addControl(new mapboxgl.NavigationControl());
          map.addControl(new mapboxgl.ScaleControl());

          await new Promise((resolve) => map.on('load', resolve));

          gisManager = new GISDataManager();
          await loadGISData();

          if (mapBounds) {
            map.fitBounds(mapBounds, { padding: 50 });
          }

          // Configurar eventos del mapa
          setupMapEvents();

          // Si estamos en modo de dibujo, configurar herramientas de dibujo
          if (isDrawingMode) {
            await setupDrawingTools();
          }

          // Verificar si estamos en modo dashboard
          const isDashboardMode = mapContainer?.getAttribute('data-dashboard-mode') === 'true';
          const canchaIdsStr = mapContainer?.getAttribute('data-cancha-ids') || '';
          
          if (isDashboardMode && canchaIdsStr) {
            // Modo dashboard: cargar m√∫ltiples canchas
            console.log('üéØ Modo Dashboard activo - Cargando m√∫ltiples canchas');
            await loadMultipleCanchas(canchaIdsStr);
          } else if (canchaId && canchaId !== '') {
            // Modo individual: cargar una sola cancha
            await loadCanchaPolygon(canchaId);
          }

          setLoading(false);
          console.log('üéâ Mapa inicializado completamente con todas las funcionalidades');
        } catch (err) {
          console.error('Error initializing map', err);
          showError('Error al inicializar el mapa: ' + (err.message || err));
          setLoading(false);
        }
      }

      async function loadGISData() {
        try {
          console.log('üîÑ Iniciando carga de datos GIS...');
          
          // Cargar geojson est√°tico desde public/mapbox-gis/
          const polygonsResponse = await fetch('/mapbox-gis/poligonos.geojson');
          if (!polygonsResponse.ok) throw new Error('No se pudo cargar poligonos');
          const polygonsData = await polygonsResponse.json();
          console.log('üìÑ Pol√≠gonos cargados:', polygonsData.features?.length || 0);

          const sectorsResponse = await fetch('/mapbox-gis/sectores.geojson');
          if (!sectorsResponse.ok) throw new Error('No se pudo cargar sectores');
          const sectorsData = await sectorsResponse.json();
          console.log('üìÑ Sectores cargados:', sectorsData.features?.length || 0);

          const convertedPolygons = {
            ...polygonsData,
            features: polygonsData.features.map(f => ({ 
              ...f, 
              geometry: convertGeometry(f.geometry), 
              properties: { 
                ...f.properties, 
                tipo: f.properties.NAME || f.properties.tipo || 'otros' 
              } 
            }))
          };

          const convertedSectors = {
            ...sectorsData,
            features: sectorsData.features.map(f => ({ 
              ...f, 
              geometry: convertGeometry(f.geometry), 
              properties: { 
                ...f.properties, 
                sector: f.properties.NAME || f.properties.sector || 'S1', 
                muro: (f.properties.NAME || f.properties.sector || '').split('_')[0] || 'MP' 
              } 
            }))
          };

          const allFeatures = [...convertedPolygons.features, ...convertedSectors.features];
          mapBounds = calculateBounds(allFeatures);

          map.addSource('poligonos', { type: 'geojson', data: convertedPolygons });
          map.addSource('sectores', { type: 'geojson', data: convertedSectors });

          // Agregar fuente raster del ortomosaico usando TileServer GL (puerto 8081)
          if (!map.getSource('ortomosaico')) {
            console.log('üó∫Ô∏è Configurando fuente del ortomosaico con TileServer GL...');
            
            // Probar diferentes URLs del tileserver
            const tileUrls = [
              'http://localhost:8081/data/mapbase/{z}/{x}/{y}.jpg',
              'http://localhost:8081/data/mapbase/{z}/{x}/{y}.png',
              'http://localhost:8081/data/mapbase/{z}/{x}/{y}.webp',
              'http://localhost:8081/data/mapbase/tiles/{z}/{x}/{y}.jpg'
            ];
            
            const tileUrl = tileUrls[0]; // Empezar con la primera
            console.log('üì° URL de tiles configurada:', tileUrl);
            console.log('üì° URLs alternativas disponibles:', tileUrls);
            
            map.addSource('ortomosaico', {
              type: 'raster',
              tiles: [tileUrl],
              tileSize: 256,
              minzoom: 10,
              maxzoom: 20,
              bounds: [-70.762292, -33.136471, -70.708471, -33.111063]
            });
            console.log('‚úÖ Fuente de ortomosaico agregada');
          }

          // PRIMERA CAPA: Ortomosaico como base (debajo de todo)
          if (!map.getLayer('raster-layer')) {
            console.log('üó∫Ô∏è Agregando capa de ortomosaico...');
            map.addLayer({ 
              id: 'raster-layer', 
              type: 'raster', 
              source: 'ortomosaico', 
              paint: { 'raster-opacity': 1.0 } 
            });
            console.log('‚úÖ Capa de ortomosaico agregada como base');
            
            // Escuchar errores espec√≠ficos de la capa de tiles
            map.on('sourcedata', function(e) {
              if (e.sourceId === 'ortomosaico') {
                console.log('üì° Estado de fuente ortomosaico:', e.type, e.isSourceLoaded);
              }
            });
            
            map.on('error', function(e) {
              if (e.error && e.error.message && e.error.message.includes('ortomosaico')) {
                console.error('‚ùå Error espec√≠fico del ortomosaico:', e.error);
              }
            });
          }

          // SEGUNDA CAPA: Contornos de sectores (VISIBLE, sin relleno)
          map.addLayer({ 
            id: 'sectors-stroke', 
            type: 'line', 
            source: 'sectores', 
            paint: { 
              'line-color': '#ffffff', 
              'line-width': 2,
              'line-dasharray': [2, 2]
            } 
          });

          // TERCERA CAPA: Contornos de pol√≠gonos (OCULTOS por defecto)
          map.addLayer({ 
            id: 'polygons-stroke', 
            type: 'line', 
            source: 'poligonos', 
            layout: { visibility: 'none' }, 
            paint: { 'line-color': '#ff7f00', 'line-width': 2, 'line-opacity': 0.8 } 
          });

          console.log('‚úÖ Todas las capas configuradas correctamente');
          setupControls();

        } catch (error) {
          console.error('‚ùå Error loading GIS data:', error);
          console.error('‚ùå Stack trace:', error.stack);
          showError('Error al cargar datos GIS: ' + (error.message || error));
          
          // No fallar completamente, intentar continuar sin datos GIS
          console.log('‚ö†Ô∏è Continuando sin datos GIS...');
        }
      }

      // Configurar filtro de muros y navegaci√≥n autom√°tica
      function setupControls() {
        const muroFilterSelect = document.getElementById('muro-filter');
        if (!muroFilterSelect) return;

        // Bounds espec√≠ficos para cada muro en coordenadas UTM 19S
        const MURO_BOUNDS_UTM = {
          MP: {
            southwest: [336060.6, 6333765.9],
            northeast: [338308.8, 6335338.4]
          },
          ME: {
            southwest: [339617.2, 6333366.6], 
            northeast: [340188.5, 6334496.9]
          },
          MO: {
            southwest: [335507.8, 6332334.6],
            northeast: [336515.2, 6333501.7]
          }
        };

        // Variable para controlar si el mapa est√° bloqueado
        let mapLocked = false;
        let currentLockedBounds = null;

        // Funci√≥n para aplicar filtro de muro
        function applyMuroFilter(filter) {
          console.log('üéØ Aplicando filtro de muro:', filter);
          
          if (filter && filter !== 'todos') {
            // Mostrar capas de pol√≠gonos y aplicar filtro
            map.setLayoutProperty('polygons-stroke', 'visibility', 'visible');
            map.setFilter('polygons-stroke', ['==', ['get', 'tipo'], filter]);
            
            // Centrar en las coordenadas espec√≠ficas del muro usando UTM
            if (MURO_BOUNDS_UTM[filter]) {
              const bounds = MURO_BOUNDS_UTM[filter];
              const sw = utmToWgs84(bounds.southwest[0], bounds.southwest[1]);
              const ne = utmToWgs84(bounds.northeast[0], bounds.northeast[1]);
              
              // Bloquear el mapa en estos l√≠mites
              mapLocked = true;
              currentLockedBounds = [sw, ne];
              
              // Aplicar restricci√≥n de l√≠mites al mapa
              map.setMaxBounds([
                [sw[0] - 0.001, sw[1] - 0.001], // Agregar un peque√±o margen
                [ne[0] + 0.001, ne[1] + 0.001]
              ]);
              
              map.fitBounds([sw, ne], {
                padding: 80,
                duration: 2000, // Transici√≥n m√°s suave y lenta
                easing: (t) => t * (2 - t) // Easing suave
              });
              
              console.log(`üîí Mapa bloqueado en muro ${filter}:`, [sw, ne]);
            }
          } else {
            // Desbloquear el mapa y volver a la vista general
            mapLocked = false;
            currentLockedBounds = null;
            
            // Remover restricci√≥n de l√≠mites
            map.setMaxBounds(null);
            
            // Ocultar pol√≠gonos y volver a la vista general
            map.setLayoutProperty('polygons-stroke', 'visibility', 'none');
            
            // Volver a la vista general
            map.fitBounds(MAP_CONFIG.bounds, {
              padding: 50,
              duration: 1500, // Transici√≥n m√°s suave
              easing: (t) => t * (2 - t) // Easing suave
            });
            console.log('üîì Mapa desbloqueado - Volviendo a vista general');
          }
        }

        // Aplicar filtro autom√°tico si se recibi√≥ como prop
        const mapContainer = document.querySelector('.map-container');
        const autoMuroFilter = mapContainer?.getAttribute('data-muro-filter') || '';
        if (autoMuroFilter && autoMuroFilter !== '') {
          console.log('ü§ñ Aplicando filtro autom√°tico de muro:', autoMuroFilter);
          // Ocultar el selector de filtro ya que es autom√°tico
          const controlPanel = muroFilterSelect.closest('.control-panel');
          if (controlPanel) {
            (controlPanel as HTMLElement).style.display = 'none';
          }
          // Aplicar el filtro autom√°ticamente
          setTimeout(() => {
            applyMuroFilter(autoMuroFilter);
          }, 1000); // Esperar un poco para que el mapa est√© listo
        } else {
          // Configurar el event listener para el filtro manual
          muroFilterSelect.addEventListener('change', (e) => {
            const filter = (e.target as HTMLSelectElement).value;
            applyMuroFilter(filter);
          });
        }

        console.log('üéÆ Controles de filtro configurados');
      }

      // Configurar eventos del mouse
      function setupMapEvents() {
        map.on('mouseenter', ['polygons-stroke', 'sectors-stroke'], () => {
          map.getCanvas().style.cursor = 'pointer';
        });

        map.on('mouseleave', ['polygons-stroke', 'sectors-stroke'], () => {
          map.getCanvas().style.cursor = '';
        });
        
        console.log('üñ±Ô∏è Eventos del mapa configurados');
      }

      // Configurar herramientas de dibujo
      async function setupDrawingTools() {
        try {
          console.log('üé® Configurando herramientas de dibujo...');
          
          // Importar MapboxDraw desde el paquete instalado
          const MapboxDraw = (await import('@mapbox/mapbox-gl-draw')).default;
          
          // Crear instancia de draw con configuraci√≥n personalizada
          const draw = new MapboxDraw({
            displayControlsDefault: false,
            controls: {
              polygon: true,
              trash: true
            },
            defaultMode: 'draw_polygon',
            styles: [
              // Estilo para pol√≠gonos activos (mientras se dibujan)
              {
                'id': 'gl-draw-polygon-fill-inactive',
                'type': 'fill',
                'filter': ['all', ['==', '$type', 'Polygon'], ['!=', 'mode', 'static']],
                'paint': {
                  'fill-color': '#3b82f6',
                  'fill-opacity': 0.2
                }
              },
              {
                'id': 'gl-draw-polygon-stroke-inactive',
                'type': 'line',
                'filter': ['all', ['==', '$type', 'Polygon'], ['!=', 'mode', 'static']],
                'layout': {
                  'line-cap': 'round',
                  'line-join': 'round'
                },
                'paint': {
                  'line-color': '#3b82f6',
                  'line-width': 3
                }
              },
              // Estilo para v√©rtices
              {
                'id': 'gl-draw-polygon-and-line-vertex-inactive',
                'type': 'circle',
                'filter': ['all', ['==', 'meta', 'vertex'], ['==', '$type', 'Point']],
                'paint': {
                  'circle-radius': 5,
                  'circle-color': '#ffffff',
                  'circle-stroke-color': '#3b82f6',
                  'circle-stroke-width': 2
                }
              }
            ]
          });
          
          // Agregar el control al mapa
          map.addControl(draw, 'top-left');
          
          // Configurar eventos del draw
          map.on('draw.create', function(e) {
            const coordinates = e.features[0].geometry.coordinates[0];
            console.log('‚úÖ Pol√≠gono creado:', coordinates);
            
            // Enviar las coordenadas al parent window
            if (window.parent) {
              window.parent.postMessage({
                type: 'polygon-drawn',
                coordinates: coordinates
              }, '*');
            }
            
            // Limpiar otros pol√≠gonos (solo uno a la vez)
            const allFeatures = draw.getAll();
            if (allFeatures.features.length > 1) {
              // Mantener solo el √∫ltimo pol√≠gono dibujado
              const latestFeature = allFeatures.features[allFeatures.features.length - 1];
              draw.deleteAll();
              draw.add(latestFeature);
            }
          });
          
          map.on('draw.update', function(e) {
            const coordinates = e.features[0].geometry.coordinates[0];
            console.log('üìù Pol√≠gono actualizado:', coordinates);
            
            // Enviar las coordenadas actualizadas al parent window
            if (window.parent) {
              window.parent.postMessage({
                type: 'polygon-drawn',
                coordinates: coordinates
              }, '*');
            }
          });
          
          map.on('draw.delete', function() {
            console.log('üóëÔ∏è Pol√≠gono eliminado');
            
            // Notificar al parent que se elimin√≥ el pol√≠gono
            if (window.parent) {
              window.parent.postMessage({
                type: 'polygon-deleted'
              }, '*');
            }
          });
          
          console.log('‚úÖ Herramientas de dibujo configuradas exitosamente');
          
        } catch (error) {
          console.error('‚ùå Error al configurar herramientas de dibujo:', error);
          showError('Error al cargar herramientas de dibujo: ' + (error as Error).message);
        }
      }

      // Cargar y mostrar m√∫ltiples canchas en modo dashboard
      async function loadMultipleCanchas(canchaIdsStr) {
        try {
          // Parsear los IDs
          const ids = canchaIdsStr.split(',').map(id => id.trim()).filter(id => id);
          
          if (ids.length === 0) {
            console.log('‚ö†Ô∏è No hay canchas para mostrar');
            return;
          }
          
          console.log('üîç Cargando m√∫ltiples canchas:', ids);
          
          // Cargar todas las canchas en paralelo
          const promises = ids.map(id => fetch(`/api/canchas/${id}`).then(r => r.json()));
          const responses = await Promise.all(promises);
          
          // Filtrar canchas v√°lidas con pol√≠gonos
          const canchasConPoligono = responses
            .filter(data => data.success && data.cancha && data.cancha.poligono_coordenadas && Array.isArray(data.cancha.poligono_coordenadas))
            .map(data => data.cancha);
          
          console.log(`üìä ${canchasConPoligono.length} de ${ids.length} canchas tienen pol√≠gonos`);
          
          // Debug: mostrar estado de cada cancha
          canchasConPoligono.forEach(cancha => {
            console.log(`üè∑Ô∏è Cancha ${cancha.nombre}: Estado ID = ${cancha.estado_actual_id}, Estado = ${cancha.estado_actual}`);
          });
          
          if (canchasConPoligono.length === 0) {
            console.log('‚ö†Ô∏è Ninguna cancha tiene pol√≠gono definido');
            return;
          }
          
          // Crear GeoJSON con todos los pol√≠gonos
          const features = canchasConPoligono.map(cancha => ({
            type: 'Feature',
            geometry: {
              type: 'Polygon',
              coordinates: [cancha.poligono_coordenadas]
            },
            properties: {
              cancha_id: cancha.id,
              cancha_nombre: cancha.nombre,
              estado_actual: cancha.estado_actual || 'Sin estado',
              estado_actual_id: cancha.estado_actual_id || 1,
              empresa_actual: cancha.empresa_actual || 'Sin empresa',
              tipo: 'cancha_area'
            }
          }));
          
          const polygonsGeoJSON = {
            type: 'FeatureCollection',
            features: features
          };
          
          // Debug: mostrar el GeoJSON generado
          console.log('üó∫Ô∏è GeoJSON generado:', JSON.stringify(polygonsGeoJSON, null, 2));
          console.log('üé® Estados de las features:', features.map(f => ({ 
            nombre: f.properties.cancha_nombre, 
            estado_id: f.properties.estado_actual_id,
            estado_nombre: f.properties.estado_actual
          })));
          
          // Remover fuentes anteriores si existen
          if (map.getSource('canchas-dashboard')) {
            map.getLayer('canchas-dashboard-fill') && map.removeLayer('canchas-dashboard-fill');
            map.getLayer('canchas-dashboard-stroke') && map.removeLayer('canchas-dashboard-stroke');
            map.removeSource('canchas-dashboard');
          }
          
          // Agregar fuente con todos los pol√≠gonos
          map.addSource('canchas-dashboard', {
            type: 'geojson',
            data: polygonsGeoJSON
          });
          
          // Agregar capas con estilos din√°micos seg√∫n estado
          // Estados:
          // 1: Creada - Azul con borde azul
          // 7: En Espera - Amarillo con borde amarillo
          // 3: En Proceso - Amarillo con borde verde
          // 4: Validada - Verde con borde amarillo
          // 8: Rechazada, en Espera - Rojo con borde amarillo
          // 6: Cerrada - Verde con borde verde
          
          console.log('üé® Aplicando colores a las capas del mapa...');
          console.log('üìä Distribuci√≥n de estados:', features.reduce((acc, f) => {
            const estadoId = f.properties.estado_actual_id;
            acc[estadoId] = (acc[estadoId] || 0) + 1;
            return acc;
          }, {}));
          
          map.addLayer({
            id: 'canchas-dashboard-fill',
            type: 'fill',
            source: 'canchas-dashboard',
            paint: {
              'fill-color': [
                'match',
                ['get', 'estado_actual_id'],
                1, '#3b82f6',  // Creada: Azul
                7, '#fbbf24',  // En Espera: Amarillo
                2, '#fbbf24',  // En Proceso: Amarillo - ID 2
                4, '#10b981',  // Validada: Verde
                8, '#ef4444',  // Rechazada, en Espera: Rojo
                6, '#10b981',  // Cerrada: Verde
                '#3b82f6'      // Default: Azul
              ],
              'fill-opacity': 0.3
            }
          });
          
          console.log('‚úÖ Capa de relleno agregada con colores din√°micos');
          
          map.addLayer({
            id: 'canchas-dashboard-stroke',
            type: 'line',
            source: 'canchas-dashboard',
            paint: {
              'line-color': [
                'match',
                ['get', 'estado_actual_id'],
                1, '#2563eb',  // Creada: Azul
                7, '#f59e0b',  // En Espera: Amarillo m√°s oscuro
                2, '#10b981',  // En Proceso: Verde - ID 2
                4, '#fbbf24',  // Validada: Amarillo
                8, '#fbbf24',  // Rechazada, en Espera: Amarillo
                6, '#059669',  // Cerrada: Verde oscuro
                '#2563eb'      // Default: Azul
              ],
              'line-width': 2,
              'line-opacity': 0.8
            }
          });
          
          console.log('‚úÖ Capa de borde agregada con colores din√°micos');
          
          // NO hacer zoom autom√°tico - mantener vista general
          // El zoom se har√° solo cuando el usuario haga doble-click en una fila de la tabla
          console.log('‚úÖ Mapa cargado en vista general (sin auto-zoom)');
          
          // Agregar popup al hacer click
          map.on('click', 'canchas-dashboard-fill', (e) => {
            const feature = e.features[0];
            const props = feature.properties;
            
            new mapboxgl.Popup()
              .setLngLat(e.lngLat)
              .setHTML(`
                <div style="padding: 0.5rem;">
                  <h4 style="margin: 0 0 0.5rem 0; font-weight: 700;">${props.cancha_nombre}</h4>
                  <p style="margin: 0.25rem 0;"><strong>Estado:</strong> ${props.estado_actual}</p>
                  <p style="margin: 0.25rem 0;"><strong>Empresa:</strong> ${props.empresa_actual}</p>
                </div>
              `)
              .addTo(map);
          });
          
          // Cambiar cursor al pasar sobre las canchas
          map.on('mouseenter', 'canchas-dashboard-fill', () => {
            map.getCanvas().style.cursor = 'pointer';
          });
          
          map.on('mouseleave', 'canchas-dashboard-fill', () => {
            map.getCanvas().style.cursor = '';
          });
          
          console.log('‚úÖ M√∫ltiples canchas mostradas exitosamente');
          
          // Escuchar mensajes del parent para hacer zoom a canchas espec√≠ficas
          window.addEventListener('message', (event) => {
            if (event.data.type === 'zoom-to-cancha') {
              const canchaId = event.data.canchaId;
              console.log('üîç Haciendo zoom a cancha:', canchaId);
              zoomToCanchaInDashboard(canchaId);
            }
          });
          
        } catch (error) {
          console.error('‚ùå Error al cargar m√∫ltiples canchas:', error);
          showError('Error al cargar las √°reas de las canchas: ' + (error as Error).message);
        }
      }
      
      // Hacer zoom a una cancha espec√≠fica en el dashboard
      function zoomToCanchaInDashboard(canchaId) {
        try {
          const source = map.getSource('canchas-dashboard');
          if (!source) {
            console.log('‚ö†Ô∏è Fuente de canchas no disponible');
            return;
          }
          
          // Obtener los features del source
          const data = source._data;
          if (!data || !data.features) return;
          
          // Encontrar la cancha espec√≠fica
          const canchaFeature = data.features.find(f => f.properties.cancha_id == canchaId);
          
          if (!canchaFeature) {
            console.log('‚ö†Ô∏è Cancha no encontrada en el mapa:', canchaId);
            return;
          }
          
          // Calcular bounds del pol√≠gono de la cancha
          const coords = canchaFeature.geometry.coordinates[0];
          const bounds = coords.reduce((bounds, coord) => {
            return bounds.extend(coord);
          }, new mapboxgl.LngLatBounds(coords[0], coords[0]));
          
          // Hacer zoom con animaci√≥n
          map.fitBounds(bounds, {
            padding: 100,
            duration: 1500,
            easing: (t) => t * (2 - t)
          });
          
          console.log('‚úÖ Zoom completado a cancha:', canchaId);
          
        } catch (error) {
          console.error('‚ùå Error al hacer zoom a cancha:', error);
        }
      }

      // Cargar y mostrar el pol√≠gono de una cancha espec√≠fica
      async function loadCanchaPolygon(canchaId) {
        try {
          console.log('üîç Cargando pol√≠gono de cancha:', canchaId);
          
          // Hacer petici√≥n al API para obtener los datos de la cancha
          const response = await fetch(`/api/canchas/${canchaId}`);
          if (!response.ok) {
            throw new Error(`Error ${response.status}: ${response.statusText}`);
          }
          
          const data = await response.json();
          console.log('üìä Respuesta completa de la API:', data);
          
          if (!data.success || !data.cancha) {
            console.error('‚ùå Error en respuesta de API:', data);
            return;
          }
          
          const cancha = data.cancha;
          console.log('üìÑ Datos de cancha extra√≠dos:', {
            id: cancha.id,
            nombre: cancha.nombre,
            poligono_presente: !!cancha.poligono_coordenadas,
            tipo_poligono: typeof cancha.poligono_coordenadas,
            es_array: Array.isArray(cancha.poligono_coordenadas),
            longitud: cancha.poligono_coordenadas?.length || 0,
            primeros_puntos: cancha.poligono_coordenadas?.slice(0, 3) || []
          });
          
          // Verificar si la cancha tiene pol√≠gono
          if (!cancha.poligono_coordenadas || !Array.isArray(cancha.poligono_coordenadas)) {
            console.log('‚ö†Ô∏è Esta cancha no tiene pol√≠gono definido');
            return;
          }
          
          // Crear GeoJSON del pol√≠gono
          const polygonGeoJSON = {
            type: 'FeatureCollection',
            features: [{
              type: 'Feature',
              geometry: {
                type: 'Polygon',
                coordinates: [cancha.poligono_coordenadas]
              },
              properties: {
                cancha_id: cancha.id,
                cancha_nombre: cancha.nombre,
                estado_actual_id: cancha.estado_actual_id || 1,
                tipo: 'cancha_area'
              }
            }]
          };
          
          // Agregar fuente del pol√≠gono al mapa
          if (map.getSource('cancha-polygon')) {
            map.removeSource('cancha-polygon');
          }
          
          map.addSource('cancha-polygon', {
            type: 'geojson',
            data: polygonGeoJSON
          });
          
          // Determinar colores seg√∫n el estado
          const estadoId = cancha.estado_actual_id || 1;
          let fillColor = '#3b82f6';  // Default: Azul (Creada)
          let strokeColor = '#2563eb'; // Default: Azul oscuro
          
          switch(estadoId) {
            case 1: // Creada
              fillColor = '#3b82f6';
              strokeColor = '#2563eb';
              break;
            case 7: // En Espera
              fillColor = '#fbbf24';
              strokeColor = '#f59e0b';
              break;
            case 2: // En Proceso - ID 2
              fillColor = '#fbbf24';
              strokeColor = '#10b981';
              break;
            case 4: // Validada
              fillColor = '#10b981';
              strokeColor = '#fbbf24';
              break;
            case 8: // Rechazada, en Espera
              fillColor = '#ef4444';
              strokeColor = '#fbbf24';
              break;
            case 6: // Cerrada
              fillColor = '#10b981';
              strokeColor = '#059669';
              break;
          }
          
          // Agregar capas del pol√≠gono con colores din√°micos
          map.addLayer({
            id: 'cancha-polygon-fill',
            type: 'fill',
            source: 'cancha-polygon',
            paint: {
              'fill-color': fillColor,
              'fill-opacity': 0.3
            }
          });
          
          map.addLayer({
            id: 'cancha-polygon-stroke',
            type: 'line',
            source: 'cancha-polygon',
            paint: {
              'line-color': strokeColor,
              'line-width': 3,
              'line-opacity': 0.8
            }
          });
          
          // No hacer zoom al pol√≠gono individual - dejar que el filtro de muro maneje la vista
          console.log('‚úÖ Pol√≠gono de cancha mostrado exitosamente - zoom manejado por filtro de muro');
          
        } catch (error) {
          console.error('‚ùå Error al cargar pol√≠gono de cancha:', error);
          showError('Error al cargar el √°rea de la cancha: ' + (error as Error).message);
        }
      }

      // Inicializar cuando el DOM est√© listo
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initializeMap);
      } else {
        initializeMap();
      }

    } catch (error) {
      console.error('Error loading Mapbox dependencies:', error);
      const errorElement = document.getElementById('error');
      if (errorElement) {
        errorElement.textContent = 'Error al cargar dependencias del mapa';
        errorElement.style.display = 'block';
      }
    }
  }

  // Inicializar mapbox
  initMapbox();
</script>
