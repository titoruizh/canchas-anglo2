---
// Componente principal del mapa de miner√≠a - Restaurado con funcionalidad completa

// Props del componente
interface Props {
  muroFilter?: string;
  drawingMode?: boolean;
  canchaId?: string;
  dashboardMode?: boolean;
  canchaIds?: string;
}

const {
  muroFilter,
  drawingMode = false,
  canchaId,
  dashboardMode = false,
  canchaIds,
} = Astro.props;
console.log("üèóÔ∏è MiningMap iniciado con:", {
  muroFilter,
  drawingMode,
  canchaId,
  dashboardMode,
  canchaIds,
});
---

<style>
  .map-container {
    position: relative;
    width: 100%;
    height: 100vh;
    max-width: 100%;
    margin: 0 auto;
    border-radius: 0;
    overflow: hidden;
  }

  #map {
    width: 100%;
    height: 100%;
  }

  .map-controls {
    position: absolute;
    top: 16px;
    right: 16px;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .control-panel {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    padding: 16px;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    min-width: 200px;
    font-family:
      "Inter",
      -apple-system,
      BlinkMacSystemFont,
      "Segoe UI",
      Roboto,
      sans-serif;
  }

  .control-group {
    margin-bottom: 16px;
  }

  .control-group:last-child {
    margin-bottom: 0;
  }

  .control-label {
    display: block;
    margin-bottom: 8px;
    font-weight: 600;
    color: #374151;
    font-size: 13px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .control-select {
    width: 100%;
    padding: 10px 12px;
    border: 1px solid #d1d5db;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 500;
    background: white;
    color: #374151;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .control-select:focus {
    outline: none;
    border-color: #3b82f6;
    box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
  }

  .loading {
    position: absolute;
    z-index: 1001;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(10px);
    padding: 24px 32px;
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    font-weight: 500;
    color: #374151;
  }

  .error {
    position: absolute;
    z-index: 1001;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: linear-gradient(135deg, #ef4444, #dc2626);
    color: white;
    padding: 12px 20px;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(239, 68, 68, 0.3);
    font-weight: 500;
    max-width: 400px;
    text-align: center;
  }
</style>

<div
  class="map-container"
  data-muro-filter={muroFilter || ""}
  data-drawing-mode={drawingMode.toString()}
  data-cancha-id={canchaId || ""}
  data-dashboard-mode={dashboardMode.toString()}
  data-cancha-ids={canchaIds || ""}
>
  <div id="map"></div>

  <div class="map-controls">
    <div class="control-panel">
      <div class="control-group">
        <label class="control-label">Filtro de Muros</label>
        <select id="muro-filter" class="control-select">
          <option value="todos">Todos los Muros</option>
          <option value="MP">MP</option>
          <option value="MO">MO</option>
          <option value="ME">ME</option>
        </select>
      </div>
    </div>
  </div>

  <div id="loading" class="loading" style="display: none;">
    Cargando mapa...
  </div>

  <div id="error" class="error" style="display: none;"></div>
</div>

<script>
  // Importar usando dynamic import para evitar problemas de m√≥dulos
  async function initMapbox() {
    try {
      const mapboxgl = await import("mapbox-gl");
      const { POLYGON_STYLES, convertGeometry, calculateBounds, utmToWgs84 } =
        await import("../utils/mapbox.js");
      const { GISDataManager, RasterManager } = await import("../utils/gis.js");

      let map;
      let gisManager;
      let mapBounds = null;

      const MAP_CONFIG = {
        center: [-70.7376, -33.1193],
        zoom: 14.6, // Zoom moderado - un poco m√°s alejado que el original
        bounds: [
          [-70.772, -33.142], // L√≠mite suroeste
          [-70.703, -33.102615], // L√≠mite noreste: 33¬∞ 06' 09.414625"
        ],
      };

      const mapElement = document.getElementById("map");
      const loadingElement = document.getElementById("loading");
      const errorElement = document.getElementById("error");

      function setLoading(loading) {
        if (loadingElement) {
          loadingElement.style.display = loading ? "block" : "none";
        }
      }

      function showError(message) {
        if (errorElement) {
          errorElement.textContent = message;
          errorElement.style.display = "block";
          setTimeout(() => {
            errorElement.style.display = "none";
          }, 5000);
        }
      }

      async function getMapboxToken() {
        try {
          const response = await fetch("/mapbox-gis/token.txt");
          if (!response.ok) {
            throw new Error(`Error ${response.status}: ${response.statusText}`);
          }
          const token = await response.text();
          const cleanToken = token.trim();

          // Validar que el token tenga el formato correcto
          if (!cleanToken.startsWith("pk.")) {
            throw new Error(
              'Token de Mapbox inv√°lido - debe comenzar con "pk."',
            );
          }

          console.log(
            "üîê Token validado correctamente:",
            cleanToken.substring(0, 20) + "...",
          );
          return cleanToken;
        } catch (error) {
          console.error("Error loading Mapbox token:", error);
          throw new Error(
            "No se pudo cargar el token de Mapbox: " + error.message,
          );
        }
      }

      async function initializeMap() {
        try {
          setLoading(true);

          // Verificar si estamos en modo de dibujo y obtener canchaId
          const mapContainer = document.querySelector(".map-container");
          const isDrawingMode =
            mapContainer?.getAttribute("data-drawing-mode") === "true";
          const canchaId = mapContainer?.getAttribute("data-cancha-id");
          console.log("üé® Modo de dibujo activo:", isDrawingMode);
          console.log("üè∑Ô∏è Cancha ID:", canchaId);

          // CR√çTICO: Establecer el token ANTES de crear el mapa
          const token = await getMapboxToken();
          console.log("üîê Token de Mapbox obtenido:", token ? "S√≠" : "No");
          console.log("üîë Token completo:", token);

          // Establecer el token en mapboxgl ANTES de crear el mapa
          mapboxgl.accessToken = token;

          // Verificar que el token se estableci√≥ correctamente
          console.log(
            "‚úÖ Token establecido en mapboxgl:",
            mapboxgl.accessToken,
          );

          map = new mapboxgl.Map({
            container: "map",
            style: {
              version: 8,
              glyphs: "mapbox://fonts/mapbox/{fontstack}/{range}.pbf", // Habilitar renderizado de texto
              sources: {},
              layers: [
                {
                  id: "background",
                  type: "background",
                  paint: { "background-color": "#f0f0f0" }, // Fondo gris neutro
                },
              ],
            },
            center: MAP_CONFIG.center,
            zoom: MAP_CONFIG.zoom,
            maxBounds: MAP_CONFIG.bounds,
            accessToken: token, // Tambi√©n pasar expl√≠citamente el token
          });

          map.addControl(new mapboxgl.NavigationControl());
          map.addControl(new mapboxgl.ScaleControl());

          await new Promise((resolve) => map.on("load", resolve));

          gisManager = new GISDataManager();
          await loadGISData();

          if (mapBounds) {
            map.fitBounds(mapBounds, { padding: 50 });
          }

          // Configurar eventos del mapa
          setupMapEvents();

          // Si estamos en modo de dibujo, configurar herramientas de dibujo
          if (isDrawingMode) {
            await setupDrawingTools();
          }

          // Verificar si estamos en modo dashboard
          const isDashboardMode =
            mapContainer?.getAttribute("data-dashboard-mode") === "true";
          const canchaIdsStr =
            mapContainer?.getAttribute("data-cancha-ids") || "";

          if (isDashboardMode && canchaIdsStr) {
            // Modo dashboard: cargar m√∫ltiples canchas
            console.log(
              "üéØ Modo Dashboard activo - Cargando m√∫ltiples canchas",
            );
            await loadMultipleCanchas(canchaIdsStr);
          } else if (canchaId && canchaId !== "") {
            // Modo individual: cargar una sola cancha
            await loadCanchaPolygon(canchaId);
          }

          setLoading(false);
          console.log(
            "üéâ Mapa inicializado completamente con todas las funcionalidades",
          );

          // Escuchar mensajes del parent para interacciones din√°micas
          window.addEventListener("message", (event) => {
            console.log("üì® Mensaje recibido:", event.data.type);

            if (event.data.type === "zoom-to-cancha") {
              const canchaId = event.data.canchaId;
              console.log("üîç Haciendo zoom a cancha:", canchaId);
              zoomToCanchaInDashboard(canchaId);
            } else if (event.data.type === "mostrar-revanchas") {
              const geojsonData = event.data.data;
              console.log(
                "üìä Mostrando revanchas georreferenciadas:",
                geojsonData,
              );
              mostrarRevanchasEnMapaElegante(geojsonData);
            } else if (event.data.type === "ocultar-revanchas") {
              console.log("‚ùå Ocultando revanchas");
              ocultarRevanchasEnMapa();
            }
          });
        } catch (err) {
          console.error("Error initializing map", err);
          showError("Error al inicializar el mapa: " + (err.message || err));
          setLoading(false);
        }
      }

      async function loadGISData() {
        try {
          console.log("üîÑ Iniciando carga de datos GIS...");

          // Cargar geojson est√°tico desde public/mapbox-gis/
          const polygonsResponse = await fetch("/mapbox-gis/poligonos.geojson");
          if (!polygonsResponse.ok)
            throw new Error("No se pudo cargar poligonos");
          const polygonsData = await polygonsResponse.json();
          console.log(
            "üìÑ Pol√≠gonos cargados:",
            polygonsData.features?.length || 0,
          );

          const sectorsResponse = await fetch("/mapbox-gis/sectores.geojson");
          if (!sectorsResponse.ok)
            throw new Error("No se pudo cargar sectores");
          const sectorsData = await sectorsResponse.json();
          console.log(
            "üìÑ Sectores cargados:",
            sectorsData.features?.length || 0,
          );

          const convertedPolygons = {
            ...polygonsData,
            features: polygonsData.features.map((f) => ({
              ...f,
              geometry: convertGeometry(f.geometry),
              properties: {
                ...f.properties,
                tipo: f.properties.NAME || f.properties.tipo || "otros",
              },
            })),
          };

          const convertedSectors = {
            ...sectorsData,
            features: sectorsData.features.map((f) => ({
              ...f,
              geometry: convertGeometry(f.geometry),
              properties: {
                ...f.properties,
                sector: f.properties.NAME || f.properties.sector || "S1",
                muro:
                  (f.properties.NAME || f.properties.sector || "").split(
                    "_",
                  )[0] || "MP",
              },
            })),
          };

          const allFeatures = [
            ...convertedPolygons.features,
            ...convertedSectors.features,
          ];
          mapBounds = calculateBounds(allFeatures);

          map.addSource("poligonos", {
            type: "geojson",
            data: convertedPolygons,
          });
          map.addSource("sectores", {
            type: "geojson",
            data: convertedSectors,
          });

          // Agregar fuente raster del ortomosaico usando TileServer GL
          if (!map.getSource("ortomosaico")) {
            console.log(
              "üó∫Ô∏è Configurando fuente del ortomosaico con TileServer GL...",
            );

            // Usar variable de entorno para tileserver (local: localhost:8081, producci√≥n: Render)
            const tileserverUrl = (
              import.meta.env.PUBLIC_TILESERVER_URL || "http://localhost:8081"
            ).replace(/\/$/, "");
            const tileUrl = `${tileserverUrl}/data/mapbase/{z}/{x}/{y}.jpg`;

            console.log("üì° URL de tiles configurada:", tileUrl);

            map.addSource("ortomosaico", {
              type: "raster",
              tiles: [tileUrl],
              tileSize: 256,
              minzoom: 10,
              maxzoom: 20,
              bounds: [-70.772, -33.142, -70.703, -33.096],
            });
            console.log("‚úÖ Fuente de ortomosaico agregada");
          }

          // PRIMERA CAPA: Ortomosaico como base (debajo de todo)
          if (!map.getLayer("raster-layer")) {
            console.log("üó∫Ô∏è Agregando capa de ortomosaico...");
            map.addLayer({
              id: "raster-layer",
              type: "raster",
              source: "ortomosaico",
              paint: { "raster-opacity": 1.0 },
            });
            console.log("‚úÖ Capa de ortomosaico agregada como base");

            // Escuchar errores espec√≠ficos de la capa de tiles
            map.on("sourcedata", function (e) {
              if (e.sourceId === "ortomosaico") {
                console.log(
                  "üì° Estado de fuente ortomosaico:",
                  e.type,
                  e.isSourceLoaded,
                );
              }
            });

            map.on("error", function (e) {
              if (
                e.error &&
                e.error.message &&
                e.error.message.includes("ortomosaico")
              ) {
                console.error("‚ùå Error espec√≠fico del ortomosaico:", e.error);
              }
            });
          }

          // SEGUNDA CAPA: Contornos de sectores (VISIBLE, sin relleno)
          map.addLayer({
            id: "sectors-stroke",
            type: "line",
            source: "sectores",
            paint: {
              "line-color": "#ffffff",
              "line-width": 2,
              "line-dasharray": [2, 2],
            },
          });

          // TERCERA CAPA: Contornos de pol√≠gonos (OCULTOS por defecto)
          map.addLayer({
            id: "polygons-stroke",
            type: "line",
            source: "poligonos",
            layout: { visibility: "none" },
            paint: {
              "line-color": "#ff7f00",
              "line-width": 2,
              "line-opacity": 0.8,
            },
          });

          // ETIQUETAS: Nombres de sectores (aparecen solo desde zoom de 100m o menos)
          map.addLayer({
            id: "sectores-labels",
            type: "symbol",
            source: "sectores",
            minzoom: 15, // Aparecen solo cuando el zoom es >= 100m de escala
            layout: {
              "text-field": ["get", "NAME"],
              "text-font": ["Open Sans Bold", "Arial Unicode MS Bold"],
              "text-size": 18,
              "text-offset": [0, 0],
              "text-anchor": "center",
              "text-letter-spacing": 0.05,
              "text-allow-overlap": false,
              "text-ignore-placement": false,
              "symbol-avoid-edges": true,
              "symbol-placement": "point",
              visibility: "visible",
            },
            paint: {
              "text-color": "#ffffff",
              "text-halo-color": "#000000",
              "text-halo-width": 2.5,
              "text-halo-blur": 1,
              "text-opacity": 1,
            },
          });

          // ETIQUETAS: Nombres de pol√≠gonos (halo azul profesional, desaparecen con zoom cercano)
          map.addLayer({
            id: "poligonos-labels",
            type: "symbol",
            source: "poligonos",
            filter: ["!=", ["get", "NAME"], "Otros"],
            minzoom: 0,
            maxzoom: 15.5, // Desaparecen cuando el zoom es mayor a ~75m de escala
            layout: {
              "text-field": [
                "concat",
                [
                  "case",
                  ["==", ["slice", ["get", "NAME"], 0, 2], "MO"],
                  "Muro Oeste",
                  ["==", ["slice", ["get", "NAME"], 0, 2], "MP"],
                  "Muro Principal",
                  ["==", ["slice", ["get", "NAME"], 0, 2], "ME"],
                  "Muro Este",
                  ["get", "NAME"],
                ],
                ["slice", ["get", "NAME"], 2],
              ],
              "text-font": ["Open Sans Bold", "Arial Unicode MS Bold"],
              "text-size": 18,
              "text-offset": [0, 0],
              "text-anchor": "center",
              "text-letter-spacing": 0.05,
              "text-allow-overlap": false,
              "text-ignore-placement": false,
              visibility: "visible",
            },
            paint: {
              "text-color": "#ffffff",
              "text-halo-color": "#2563eb",
              "text-halo-width": 3,
              "text-halo-blur": 1,
              "text-opacity": 1,
            },
          });

          console.log("‚úÖ Todas las capas configuradas correctamente");
          setupControls();
        } catch (error) {
          console.error("‚ùå Error loading GIS data:", error);
          console.error("‚ùå Stack trace:", error.stack);
          showError("Error al cargar datos GIS: " + (error.message || error));

          // No fallar completamente, intentar continuar sin datos GIS
          console.log("‚ö†Ô∏è Continuando sin datos GIS...");
        }
      }

      // Configurar filtro de muros y navegaci√≥n autom√°tica
      function setupControls() {
        const muroFilterSelect = document.getElementById("muro-filter");
        if (!muroFilterSelect) return;

        // Bounds espec√≠ficos para cada muro en coordenadas UTM 19S
        const MURO_BOUNDS_UTM = {
          MP: {
            southwest: [336060.6, 6333765.9],
            northeast: [338308.8, 6335338.4],
          },
          ME: {
            southwest: [339617.2, 6333366.6],
            northeast: [340188.5, 6334496.9],
          },
          MO: {
            southwest: [335507.8, 6332334.6],
            northeast: [336515.2, 6333501.7],
          },
        };

        // Variable para controlar si el mapa est√° bloqueado
        let mapLocked = false;
        let currentLockedBounds = null;

        // Funci√≥n para aplicar filtro de muro
        function applyMuroFilter(filter) {
          console.log("üéØ Aplicando filtro de muro:", filter);

          if (filter && filter !== "todos") {
            // Mostrar capas de pol√≠gonos y aplicar filtro
            map.setLayoutProperty("polygons-stroke", "visibility", "visible");
            map.setFilter("polygons-stroke", ["==", ["get", "tipo"], filter]);
            // Las etiquetas ya est√°n siempre visibles, solo aplicar filtro
            map.setFilter("poligonos-labels", [
              "all",
              ["!=", ["get", "NAME"], "Otros"],
              ["==", ["get", "tipo"], filter],
            ]);

            // Centrar en las coordenadas espec√≠ficas del muro usando UTM
            if (MURO_BOUNDS_UTM[filter]) {
              const bounds = MURO_BOUNDS_UTM[filter];
              const sw = utmToWgs84(bounds.southwest[0], bounds.southwest[1]);
              const ne = utmToWgs84(bounds.northeast[0], bounds.northeast[1]);

              // Bloquear el mapa en estos l√≠mites
              mapLocked = true;
              currentLockedBounds = [sw, ne];

              // Aplicar restricci√≥n de l√≠mites al mapa
              map.setMaxBounds([
                [sw[0] - 0.001, sw[1] - 0.001], // Agregar un peque√±o margen
                [ne[0] + 0.001, ne[1] + 0.001],
              ]);

              map.fitBounds([sw, ne], {
                padding: 80,
                duration: 2000, // Transici√≥n m√°s suave y lenta
                easing: (t) => t * (2 - t), // Easing suave
              });

              console.log(`üîí Mapa bloqueado en muro ${filter}:`, [sw, ne]);
            }
          } else {
            // Desbloquear el mapa y volver a la vista general
            mapLocked = false;
            currentLockedBounds = null;

            // Remover restricci√≥n de l√≠mites
            map.setMaxBounds(null);

            // Ocultar pol√≠gonos y volver a la vista general
            map.setLayoutProperty("polygons-stroke", "visibility", "none");
            // Restaurar filtro de etiquetas para mostrar todas (excepto "Otros")
            map.setFilter("poligonos-labels", ["!=", ["get", "NAME"], "Otros"]);

            // Volver a la vista general
            map.fitBounds(MAP_CONFIG.bounds, {
              padding: 50,
              duration: 1500, // Transici√≥n m√°s suave
              easing: (t) => t * (2 - t), // Easing suave
            });
            console.log("üîì Mapa desbloqueado - Volviendo a vista general");
          }
        }

        // Aplicar filtro autom√°tico si se recibi√≥ como prop
        const mapContainer = document.querySelector(".map-container");
        const autoMuroFilter =
          mapContainer?.getAttribute("data-muro-filter") || "";
        if (autoMuroFilter && autoMuroFilter !== "") {
          console.log(
            "ü§ñ Aplicando filtro autom√°tico de muro:",
            autoMuroFilter,
          );
          // Ocultar el selector de filtro ya que es autom√°tico
          const controlPanel = muroFilterSelect.closest(".control-panel");
          if (controlPanel) {
            (controlPanel as HTMLElement).style.display = "none";
          }
          // Aplicar el filtro autom√°ticamente
          setTimeout(() => {
            applyMuroFilter(autoMuroFilter);
          }, 1000); // Esperar un poco para que el mapa est√© listo
        } else {
          // Configurar el event listener para el filtro manual
          muroFilterSelect.addEventListener("change", (e) => {
            const filter = (e.target as HTMLSelectElement).value;
            applyMuroFilter(filter);
          });
        }

        console.log("üéÆ Controles de filtro configurados");
      }

      // Configurar eventos del mouse
      function setupMapEvents() {
        map.on("mouseenter", ["polygons-stroke", "sectors-stroke"], () => {
          map.getCanvas().style.cursor = "pointer";
        });

        map.on("mouseleave", ["polygons-stroke", "sectors-stroke"], () => {
          map.getCanvas().style.cursor = "";
        });

        console.log("üñ±Ô∏è Eventos del mapa configurados");
      }

      // Configurar herramientas de dibujo
      async function setupDrawingTools() {
        try {
          console.log("üé® Configurando herramientas de dibujo...");

          // Importar MapboxDraw desde el paquete instalado
          const MapboxDraw = (await import("@mapbox/mapbox-gl-draw")).default;

          // Crear instancia de draw con configuraci√≥n personalizada
          const draw = new MapboxDraw({
            displayControlsDefault: false,
            controls: {
              polygon: true,
              trash: true,
            },
            defaultMode: "draw_polygon",
            styles: [
              // Estilo para pol√≠gonos activos (mientras se dibujan)
              {
                id: "gl-draw-polygon-fill-inactive",
                type: "fill",
                filter: [
                  "all",
                  ["==", "$type", "Polygon"],
                  ["!=", "mode", "static"],
                ],
                paint: {
                  "fill-color": "#3b82f6",
                  "fill-opacity": 0.2,
                },
              },
              {
                id: "gl-draw-polygon-stroke-inactive",
                type: "line",
                filter: [
                  "all",
                  ["==", "$type", "Polygon"],
                  ["!=", "mode", "static"],
                ],
                layout: {
                  "line-cap": "round",
                  "line-join": "round",
                },
                paint: {
                  "line-color": "#3b82f6",
                  "line-width": 3,
                },
              },
              // Estilo para v√©rtices
              {
                id: "gl-draw-polygon-and-line-vertex-inactive",
                type: "circle",
                filter: [
                  "all",
                  ["==", "meta", "vertex"],
                  ["==", "$type", "Point"],
                ],
                paint: {
                  "circle-radius": 5,
                  "circle-color": "#ffffff",
                  "circle-stroke-color": "#3b82f6",
                  "circle-stroke-width": 2,
                },
              },
            ],
          });

          // Agregar el control al mapa
          map.addControl(draw, "top-left");

          // Configurar eventos del draw
          map.on("draw.create", function (e) {
            const coordinates = e.features[0].geometry.coordinates[0];
            console.log("‚úÖ Pol√≠gono creado:", coordinates);

            // Enviar las coordenadas al parent window
            if (window.parent) {
              window.parent.postMessage(
                {
                  type: "polygon-drawn",
                  coordinates: coordinates,
                },
                "*",
              );
            }

            // Limpiar otros pol√≠gonos (solo uno a la vez)
            const allFeatures = draw.getAll();
            if (allFeatures.features.length > 1) {
              // Mantener solo el √∫ltimo pol√≠gono dibujado
              const latestFeature =
                allFeatures.features[allFeatures.features.length - 1];
              draw.deleteAll();
              draw.add(latestFeature);
            }
          });

          map.on("draw.update", function (e) {
            const coordinates = e.features[0].geometry.coordinates[0];
            console.log("üìù Pol√≠gono actualizado:", coordinates);

            // Enviar las coordenadas actualizadas al parent window
            if (window.parent) {
              window.parent.postMessage(
                {
                  type: "polygon-drawn",
                  coordinates: coordinates,
                },
                "*",
              );
            }
          });

          map.on("draw.delete", function () {
            console.log("üóëÔ∏è Pol√≠gono eliminado");

            // Notificar al parent que se elimin√≥ el pol√≠gono
            if (window.parent) {
              window.parent.postMessage(
                {
                  type: "polygon-deleted",
                },
                "*",
              );
            }
          });

          console.log("‚úÖ Herramientas de dibujo configuradas exitosamente");
        } catch (error) {
          console.error(
            "‚ùå Error al configurar herramientas de dibujo:",
            error,
          );
          showError(
            "Error al cargar herramientas de dibujo: " +
              (error as Error).message,
          );
        }
      }

      // Cargar y mostrar m√∫ltiples canchas en modo dashboard
      async function loadMultipleCanchas(canchaIdsStr) {
        try {
          // Parsear los IDs
          const ids = canchaIdsStr
            .split(",")
            .map((id) => id.trim())
            .filter((id) => id);

          if (ids.length === 0) {
            console.log("‚ö†Ô∏è No hay canchas para mostrar");
            return;
          }

          console.log("üîç Cargando m√∫ltiples canchas:", ids);

          // Cargar todas las canchas en paralelo
          const promises = ids.map((id) =>
            fetch(`/api/canchas/${id}`).then((r) => r.json()),
          );
          const responses = await Promise.all(promises);

          // Filtrar canchas v√°lidas con pol√≠gonos
          const canchasConPoligono = responses
            .filter(
              (data) =>
                data.success &&
                data.cancha &&
                data.cancha.poligono_coordenadas &&
                Array.isArray(data.cancha.poligono_coordenadas),
            )
            .map((data) => data.cancha);

          console.log(
            `üìä ${canchasConPoligono.length} de ${ids.length} canchas tienen pol√≠gonos`,
          );

          // Debug: mostrar estado de cada cancha
          canchasConPoligono.forEach((cancha) => {
            console.log(
              `üè∑Ô∏è Cancha ${cancha.nombre}: Estado ID = ${cancha.estado_actual_id}, Estado = ${cancha.estado_actual}`,
            );
          });

          if (canchasConPoligono.length === 0) {
            console.log("‚ö†Ô∏è Ninguna cancha tiene pol√≠gono definido");
            return;
          }

          // Crear GeoJSON con todos los pol√≠gonos
          const features = canchasConPoligono.map((cancha) => ({
            type: "Feature",
            geometry: {
              type: "Polygon",
              coordinates: [cancha.poligono_coordenadas],
            },
            properties: {
              cancha_id: cancha.id,
              cancha_nombre: cancha.nombre,
              estado_actual: cancha.estado_actual || "Sin estado",
              estado_actual_id: cancha.estado_actual_id || 1,
              empresa_actual: cancha.empresa_actual || "Sin empresa",
              tipo: "cancha_area",
            },
          }));

          const polygonsGeoJSON = {
            type: "FeatureCollection",
            features: features,
          };

          // Debug: mostrar el GeoJSON generado
          console.log(
            "üó∫Ô∏è GeoJSON generado:",
            JSON.stringify(polygonsGeoJSON, null, 2),
          );
          console.log(
            "üé® Estados de las features:",
            features.map((f) => ({
              nombre: f.properties.cancha_nombre,
              estado_id: f.properties.estado_actual_id,
              estado_nombre: f.properties.estado_actual,
            })),
          );

          // Remover fuentes anteriores si existen
          if (map.getSource("canchas-dashboard")) {
            map.getLayer("canchas-dashboard-fill") &&
              map.removeLayer("canchas-dashboard-fill");
            map.getLayer("canchas-dashboard-stroke") &&
              map.removeLayer("canchas-dashboard-stroke");
            map.removeSource("canchas-dashboard");
          }

          // Agregar fuente con todos los pol√≠gonos
          map.addSource("canchas-dashboard", {
            type: "geojson",
            data: polygonsGeoJSON,
          });

          // Agregar capas con estilos din√°micos seg√∫n estado
          // Estados:
          // 1: Creada - Azul con borde azul
          // 7: En Espera - Amarillo con borde amarillo
          // 3: En Proceso - Amarillo con borde verde
          // 4: Validada - Verde con borde amarillo
          // 8: Rechazada, en Espera - Rojo con borde amarillo
          // 6: Cerrada - Verde con borde verde

          console.log("üé® Aplicando colores a las capas del mapa...");
          console.log(
            "üìä Distribuci√≥n de estados:",
            features.reduce((acc, f) => {
              const estadoId = f.properties.estado_actual_id;
              acc[estadoId] = (acc[estadoId] || 0) + 1;
              return acc;
            }, {}),
          );

          map.addLayer({
            id: "canchas-dashboard-fill",
            type: "fill",
            source: "canchas-dashboard",
            paint: {
              "fill-color": [
                "match",
                ["get", "estado_actual_id"],
                1,
                "#3b82f6", // Creada: Azul
                7,
                "#fbbf24", // En Espera: Amarillo
                2,
                "#fbbf24", // En Proceso: Amarillo - ID 2
                4,
                "#10b981", // Validada: Verde
                8,
                "#ef4444", // Rechazada, en Espera: Rojo
                6,
                "#10b981", // Cerrada: Verde
                "#3b82f6", // Default: Azul
              ],
              "fill-opacity": 0.3,
            },
          });

          console.log("‚úÖ Capa de relleno agregada con colores din√°micos");

          map.addLayer({
            id: "canchas-dashboard-stroke",
            type: "line",
            source: "canchas-dashboard",
            paint: {
              "line-color": [
                "match",
                ["get", "estado_actual_id"],
                1,
                "#2563eb", // Creada: Azul
                7,
                "#f59e0b", // En Espera: Amarillo m√°s oscuro
                2,
                "#10b981", // En Proceso: Verde - ID 2
                4,
                "#fbbf24", // Validada: Amarillo
                8,
                "#fbbf24", // Rechazada, en Espera: Amarillo
                6,
                "#059669", // Cerrada: Verde oscuro
                "#2563eb", // Default: Azul
              ],
              "line-width": 2,
              "line-opacity": 0.8,
            },
          });

          console.log("‚úÖ Capa de borde agregada con colores din√°micos");

          // NO hacer zoom autom√°tico - mantener vista general
          // El zoom se har√° solo cuando el usuario haga doble-click en una fila de la tabla
          console.log("‚úÖ Mapa cargado en vista general (sin auto-zoom)");

          // Agregar popup al hacer click
          map.on("click", "canchas-dashboard-fill", (e) => {
            const feature = e.features[0];
            const props = feature.properties;

            new mapboxgl.Popup()
              .setLngLat(e.lngLat)
              .setHTML(
                `
                <div style="padding: 0.5rem;">
                  <h4 style="margin: 0 0 0.5rem 0; font-weight: 700;">${props.cancha_nombre}</h4>
                  <p style="margin: 0.25rem 0;"><strong>Estado:</strong> ${props.estado_actual}</p>
                  <p style="margin: 0.25rem 0;"><strong>Empresa:</strong> ${props.empresa_actual}</p>
                </div>
              `,
              )
              .addTo(map);
          });

          // Cambiar cursor al pasar sobre las canchas
          map.on("mouseenter", "canchas-dashboard-fill", () => {
            map.getCanvas().style.cursor = "pointer";
          });

          map.on("mouseleave", "canchas-dashboard-fill", () => {
            map.getCanvas().style.cursor = "";
          });

          console.log("‚úÖ M√∫ltiples canchas mostradas exitosamente");
        } catch (error) {
          console.error("‚ùå Error al cargar m√∫ltiples canchas:", error);
          showError(
            "Error al cargar las √°reas de las canchas: " +
              (error as Error).message,
          );
        }
      }

      // Hacer zoom a una cancha espec√≠fica en el dashboard
      function zoomToCanchaInDashboard(canchaId) {
        try {
          const source = map.getSource("canchas-dashboard");
          if (!source) {
            console.log("‚ö†Ô∏è Fuente de canchas no disponible");
            return;
          }

          // Obtener los features del source
          const data = source._data;
          if (!data || !data.features) return;

          // Encontrar la cancha espec√≠fica
          const canchaFeature = data.features.find(
            (f) => f.properties.cancha_id == canchaId,
          );

          if (!canchaFeature) {
            console.log("‚ö†Ô∏è Cancha no encontrada en el mapa:", canchaId);
            return;
          }

          // Calcular bounds del pol√≠gono de la cancha
          const coords = canchaFeature.geometry.coordinates[0];
          const bounds = coords.reduce(
            (bounds, coord) => {
              return bounds.extend(coord);
            },
            new mapboxgl.LngLatBounds(coords[0], coords[0]),
          );

          // Hacer zoom con animaci√≥n
          map.fitBounds(bounds, {
            padding: 100,
            duration: 1500,
            easing: (t) => t * (2 - t),
          });

          console.log("‚úÖ Zoom completado a cancha:", canchaId);
        } catch (error) {
          console.error("‚ùå Error al hacer zoom a cancha:", error);
        }
      }

      // =====================================================
      // FUNCIONES PARA VISUALIZAR REVANCHAS GEORREFERENCIADAS
      // =====================================================

      // Mostrar revanchas en el mapa con visualizaci√≥n moderna
      function mostrarRevanchasEnMapa_UNUSED(geojsonData) {
        const pulseLayers = []; // Fix lint error
        return; // Unused
        try {
          if (!map) {
            console.log("‚ö†Ô∏è Mapa no inicializado");
            return;
          }

          console.log(
            "üìä Mostrando",
            geojsonData.features.length,
            "revanchas en el mapa",
          );

          // Funci√≥n para determinar color seg√∫n estado de revancha
          // Seg√∫n documentaci√≥n: Verde >3.5m (OK), Amarillo 3.0-3.5m (Precauci√≥n), Rojo <3.0m (Cr√≠tico)
          const getColorByRevancha = (revancha) => {
            if (!revancha || revancha === 0) return "#94a3b8"; // Gris - Sin datos
            if (revancha > 3.5) return "#10b981"; // Verde - OK (>3.5m)
            if (revancha >= 3.0) return "#fbbf24"; // Amarillo - Precauci√≥n (3.0-3.5m)
            return "#ef4444"; // Rojo - Cr√≠tico (<3.0m)
          };

          // Enriquecer features con colores din√°micos
          const enrichedFeatures = geojsonData.features.map((feature) => ({
            ...feature,
            properties: {
              ...feature.properties,
              dynamic_color: getColorByRevancha(feature.properties.revancha),
            },
          }));

          // Funci√≥n para calcular distancia entre dos puntos (Haversine)
          const getDistance = (coord1, coord2) => {
            const R = 6371000; // Radio de la Tierra en metros
            const lat1 = (coord1[1] * Math.PI) / 180;
            const lat2 = (coord2[1] * Math.PI) / 180;
            const deltaLat = ((coord2[1] - coord1[1]) * Math.PI) / 180;
            const deltaLon = ((coord2[0] - coord1[0]) * Math.PI) / 180;

            const a =
              Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
              Math.cos(lat1) *
                Math.cos(lat2) *
                Math.sin(deltaLon / 2) *
                Math.sin(deltaLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
          };

          // Crear l√≠neas de conexi√≥n basadas en DISTANCIA (m√°ximo 100m entre puntos)
          const lineFeatures = [];
          const MAX_DISTANCE = 100; // metros

          for (let i = 0; i < enrichedFeatures.length; i++) {
            const current = enrichedFeatures[i];

            // Buscar puntos cercanos (dentro de 100m)
            for (let j = i + 1; j < enrichedFeatures.length; j++) {
              const next = enrichedFeatures[j];
              const distance = getDistance(
                current.geometry.coordinates,
                next.geometry.coordinates,
              );

              // Solo conectar si est√°n a menos de 100m
              if (distance <= MAX_DISTANCE) {
                lineFeatures.push({
                  type: "Feature",
                  geometry: {
                    type: "LineString",
                    coordinates: [
                      current.geometry.coordinates,
                      next.geometry.coordinates,
                    ],
                  },
                  properties: {
                    from_pk: current.properties.pk,
                    to_pk: next.properties.pk,
                    from_color: current.properties.dynamic_color,
                    to_color: next.properties.dynamic_color,
                    distance: distance,
                  },
                });
              }
            }
          }

          console.log(
            `üîó ${lineFeatures.length} conexiones creadas basadas en distancia (<100m)`,
          );

          const enrichedGeoJSON = {
            type: "FeatureCollection",
            features: enrichedFeatures,
          };

          const linesGeoJSON = {
            type: "FeatureCollection",
            features: lineFeatures,
          };

          // Limpiar capas existentes
          if (map.getLayer("revanchas-labels"))
            map.removeLayer("revanchas-labels");
          if (map.getLayer("revanchas-glow-inner"))
            map.removeLayer("revanchas-glow-inner");
          if (map.getLayer("revanchas-pulse-1"))
            map.removeLayer("revanchas-pulse-1");
          if (map.getLayer("revanchas-pulse-2"))
            map.removeLayer("revanchas-pulse-2");
          if (map.getLayer("revanchas-pulse-3"))
            map.removeLayer("revanchas-pulse-3");
          if (map.getLayer("revanchas-pulse-4"))
            map.removeLayer("revanchas-pulse-4");
          if (map.getLayer("revanchas-connections"))
            map.removeLayer("revanchas-connections");
          if (map.getSource("revanchas-source"))
            map.removeSource("revanchas-source");
          if (map.getSource("revanchas-lines"))
            map.removeSource("revanchas-lines");

          // Agregar sources
          map.addSource("revanchas-source", {
            type: "geojson",
            data: enrichedGeoJSON,
          });

          map.addSource("revanchas-lines", {
            type: "geojson",
            data: linesGeoJSON,
          });

          // CAPA 1: L√≠neas de conexi√≥n con degradado
          map.addLayer({
            id: "revanchas-connections",
            type: "line",
            source: "revanchas-lines",
            paint: {
              "line-color": ["get", "from_color"],
              "line-width": [
                "interpolate",
                ["linear"],
                ["zoom"],
                12,
                1.5,
                16,
                3,
                20,
                5,
              ],
              "line-opacity": 0.25,
              "line-blur": 2,
            },
            layout: {
              "line-cap": "round",
              "line-join": "round",
            },
          });

          // CAPAS DE ONDAS EXPANSIVAS TIPO SONAR ELEGANTE
          // Dise√±o sutil y profesional - opacidades muy reducidas

          // Onda 4 - M√°s externa (casi invisible, efecto de disipaci√≥n)
          map.addLayer({
            id: "revanchas-pulse-4",
            type: "circle",
            source: "revanchas-source",
            paint: {
              "circle-radius": [
                "interpolate",
                ["linear"],
                ["zoom"],
                12,
                16,
                16,
                28,
                20,
                48,
              ],
              "circle-color": ["get", "dynamic_color"],
              "circle-opacity": 0.02,
              "circle-blur": 1.5,
            },
          });

          // N√∫cleo central - muy sutil, marca la posici√≥n real
          map.addLayer({
            id: "revanchas-glow-inner",
            type: "circle",
            source: "revanchas-source",
            paint: {
              "circle-radius": [
                "interpolate",
                ["linear"],
                ["zoom"],
                12,
                2,
                16,
                4,
                20,
                8,
              ],
              "circle-color": ["get", "dynamic_color"],
              "circle-opacity": 0.4,
              "circle-blur": 0.8,
            },
          });

          // Etiquetas (solo visibles en zoom cercano)
          map.addLayer({
            id: "revanchas-labels",
            type: "symbol",
            source: "revanchas-source",
            layout: {
              "text-field": ["get", "pk"],
              "text-font": ["Open Sans Bold", "Arial Unicode MS Bold"],
              "text-size": 11,
              "text-offset": [0, 0],
              "text-anchor": "center",
            },
            paint: {
              "text-color": "#ffffff",
              "text-halo-color": ["get", "dynamic_color"],
              "text-halo-width": 3,
              "text-halo-blur": 1.5,
              "text-opacity": 0.9,
            },
            minzoom: 15,
          });

          // ANIMACI√ìN SONAR REAL - Ondas que viajan del centro hacia afuera
          let sonarPhase = 0;
          function animateElegantSonar() {
            if (!map.getLayer("revanchas-pulse-1")) return;

            // Velocidad lenta para efecto "radar"
            sonarPhase = (sonarPhase + 0.004) % 1;

            // Configuraci√≥n de expansi√≥n por nivel de zoom
            // Radio m√°ximo al que llega la onda antes de desaparecer
            const maxRadiusStops = [
              12,
              20, // Zoom 12 -> 20px radio
              16,
              60, // Zoom 16 -> 60px radio
              20,
              120, // Zoom 20 -> 120px radio
            ];

            pulseLayers.forEach((layerId, index) => {
              // Calcular fase individual para esta capa (0.0 a 1.0)
              // Desfase equitativo: 0, 0.25, 0.5, 0.75
              const layerPhase = (sonarPhase + index / pulseLayers.length) % 1;

              // Opacidad: Empieza en 0.2 y baja a 0
              // Usamos una curva suave: (1 - t)^1.5 para que dure un poco m√°s visible al principio
              const opacity = 0.2 * Math.pow(1 - layerPhase, 1.5);

              // Radio: Crece linealmente de 0 a MaxRadius
              // Multiplicamos el radio base (calculado por zoom) por la fase
              const radiusExpression = [
                "interpolate",
                ["linear"],
                ["zoom"],
                maxRadiusStops[0],
                maxRadiusStops[1] * layerPhase,
                maxRadiusStops[2],
                maxRadiusStops[3] * layerPhase,
                maxRadiusStops[4],
                maxRadiusStops[5] * layerPhase,
              ];

              try {
                map.setPaintProperty(layerId, "circle-opacity", opacity);
                map.setPaintProperty(
                  layerId,
                  "circle-radius",
                  radiusExpression,
                );
              } catch (e) {
                // Ignorar errores si la capa no est√° lista
              }
            });

            requestAnimationFrame(animateElegantSonar);
          }
          animateElegantSonar();

          // Popup mejorado al hacer clic en el √°rea de la onda
          map.on("click", "revanchas-pulse-1", (e) => {
            const feature = e.features[0];
            const props = feature.properties;

            // Determinar badge de estado seg√∫n documentaci√≥n
            let estadoBadge = "";
            const revancha = parseFloat(props.revancha) || 0;
            if (revancha === 0) {
              estadoBadge = `<span style="background: #94a3b8; color: white; padding: 4px 10px; border-radius: 12px; font-weight: bold; font-size: 11px;">‚ö™ SIN DATOS</span>`;
            } else if (revancha > 3.5) {
              estadoBadge = `<span style="background: #10b981; color: white; padding: 4px 10px; border-radius: 12px; font-weight: bold; font-size: 11px;">‚úÖ OK</span>`;
            } else if (revancha >= 3.0) {
              estadoBadge = `<span style="background: #fbbf24; color: white; padding: 4px 10px; border-radius: 12px; font-weight: bold; font-size: 11px;">‚ö†Ô∏è PRECAUCI√ìN</span>`;
            } else {
              estadoBadge = `<span style="background: #ef4444; color: white; padding: 4px 10px; border-radius: 12px; font-weight: bold; font-size: 11px;">üî¥ CR√çTICO</span>`;
            }

            const html = `
              <div style="padding: 12px; min-width: 260px; font-family: 'Inter', sans-serif;">
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                  <h3 style="margin: 0; color: ${props.dynamic_color}; font-size: 18px; font-weight: bold;">
                    üìç ${props.muro} - ${props.sector}
                  </h3>
                  ${estadoBadge}
                </div>
                
                <div style="background: #f8fafc; padding: 10px; border-radius: 8px; margin-bottom: 10px;">
                  <div style="font-size: 13px; color: #64748b; margin-bottom: 6px;">
                    <strong style="color: #334155;">PK:</strong> ${props.pk}
                  </div>
                  <div style="font-size: 12px; color: #94a3b8;">
                    üìÖ ${new Date(props.fecha_medicion).toLocaleDateString("es-CL")}
                  </div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; font-size: 11px;">
                  <div style="background: ${revancha > 0 ? "#fef2f2" : "#f9fafb"}; padding: 8px; border-radius: 6px; border-left: 3px solid ${revancha > 0 ? "#ef4444" : "#e5e7eb"};">
                    <strong style="color: #64748b;">Revancha:</strong><br>
                    <span style="color: ${revancha > 0 ? "#ef4444" : "#94a3b8"}; font-weight: bold; font-size: 14px;">${revancha.toFixed(3)} m</span>
                  </div>
                  <div style="background: ${props.ancho > 0 ? "#eff6ff" : "#f9fafb"}; padding: 8px; border-radius: 6px; border-left: 3px solid ${props.ancho > 0 ? "#3b82f6" : "#e5e7eb"};">
                    <strong style="color: #64748b;">Ancho:</strong><br>
                    <span style="color: ${props.ancho > 0 ? "#3b82f6" : "#94a3b8"}; font-weight: bold; font-size: 14px;">${parseFloat(props.ancho || 0).toFixed(3)} m</span>
                  </div>
                  <div style="background: ${props.coronamiento > 0 ? "#faf5ff" : "#f9fafb"}; padding: 8px; border-radius: 6px; border-left: 3px solid ${props.coronamiento > 0 ? "#8b5cf6" : "#e5e7eb"};">
                    <strong style="color: #64748b;">Coronamiento:</strong><br>
                    <span style="color: ${props.coronamiento > 0 ? "#8b5cf6" : "#94a3b8"}; font-weight: bold; font-size: 14px;">${parseFloat(props.coronamiento || 0).toFixed(3)} m</span>
                  </div>
                  <div style="background: ${props.lama > 0 ? "#ecfeff" : "#f9fafb"}; padding: 8px; border-radius: 6px; border-left: 3px solid ${props.lama > 0 ? "#06b6d4" : "#e5e7eb"};">
                    <strong style="color: #64748b;">Lama:</strong><br>
                    <span style="color: ${props.lama > 0 ? "#06b6d4" : "#94a3b8"}; font-weight: bold; font-size: 14px;">${parseFloat(props.lama || 0).toFixed(3)} m</span>
                  </div>
                </div>
              </div>
            `;

            new mapboxgl.Popup({ maxWidth: "340px" })
              .setLngLat(e.lngLat)
              .setHTML(html)
              .addTo(map);
          });

          // Cambiar cursor al hover sobre las ondas
          map.on("mouseenter", "revanchas-pulse-1", () => {
            map.getCanvas().style.cursor = "pointer";
          });

          map.on("mouseleave", "revanchas-pulse-1", () => {
            map.getCanvas().style.cursor = "";
          });

          // Ajustar zoom autom√°ticamente a todos los puntos
          if (geojsonData.features && geojsonData.features.length > 0) {
            const bounds = new mapboxgl.LngLatBounds();

            geojsonData.features.forEach((feature) => {
              if (feature.geometry && feature.geometry.coordinates) {
                bounds.extend(feature.geometry.coordinates);
              }
            });

            map.fitBounds(bounds, {
              padding: { top: 80, bottom: 80, left: 80, right: 80 },
              duration: 2000,
              easing: (t) => t * (2 - t),
              maxZoom: 14,
            });

            console.log(
              "‚úÖ Zoom ajustado a",
              geojsonData.features.length,
              "revanchas",
            );
          }

          console.log(
            "‚úÖ Capa de revanchas con efectos visuales modernos agregada exitosamente",
          );
        } catch (error) {
          console.error("‚ùå Error al mostrar revanchas:", error);
        }
      }

      // Ocultar revanchas del mapa
      function ocultarRevanchasEnMapa() {
        try {
          if (!map) return;

          console.log("üîÑ Removiendo capas de revanchas...");

          // Remover todas las capas en orden inverso a como fueron agregadas
          const layersToRemove = [
            "revanchas-labels",
            "revanchas-glow-inner",
            "revanchas-pulse-1",
            "revanchas-pulse-2",
            "revanchas-pulse-3",
            "revanchas-pulse-4",
            "revanchas-connections",
            // Width lines (l√≠neas perpendiculares de ancho)
            "width-lines-layer",
            "width-pulse-1",
            "width-pulse-2",
            "width-pulse-3",
            // Nombres antiguos por si acaso
            "revanchas-pulse-outer",
            "revanchas-pulse-inner",
            "revanchas-point",
            "revanchas-layer",
          ];

          layersToRemove.forEach((layerId) => {
            if (map.getLayer(layerId)) {
              map.removeLayer(layerId);
              console.log(`  ‚úì Capa ${layerId} removida`);
            }
          });

          // Remover sources
          if (map.getSource("revanchas-source")) {
            map.removeSource("revanchas-source");
            console.log("  ‚úì Source revanchas-source removido");
          }

          if (map.getSource("revanchas-lines")) {
            map.removeSource("revanchas-lines");
            console.log("  ‚úì Source revanchas-lines removido");
          }

          if (map.getSource("width-lines")) {
            map.removeSource("width-lines");
            console.log("  ‚úì Source width-lines removido");
          }

          console.log("‚úÖ Todas las capas de revanchas removidas exitosamente");
        } catch (error) {
          console.error("‚ùå Error al ocultar revanchas:", error);
        }
      }

      // Cargar y mostrar el pol√≠gono de una cancha espec√≠fica
      async function loadCanchaPolygon(canchaId) {
        try {
          console.log("üîç Cargando pol√≠gono de cancha:", canchaId);

          // Hacer petici√≥n al API para obtener los datos de la cancha
          const response = await fetch(`/api/canchas/${canchaId}`);
          if (!response.ok) {
            throw new Error(`Error ${response.status}: ${response.statusText}`);
          }

          const data = await response.json();
          console.log("üìä Respuesta completa de la API:", data);

          if (!data.success || !data.cancha) {
            console.error("‚ùå Error en respuesta de API:", data);
            return;
          }

          const cancha = data.cancha;
          console.log("üìÑ Datos de cancha extra√≠dos:", {
            id: cancha.id,
            nombre: cancha.nombre,
            poligono_presente: !!cancha.poligono_coordenadas,
            tipo_poligono: typeof cancha.poligono_coordenadas,
            es_array: Array.isArray(cancha.poligono_coordenadas),
            longitud: cancha.poligono_coordenadas?.length || 0,
            primeros_puntos: cancha.poligono_coordenadas?.slice(0, 3) || [],
          });

          // Verificar si la cancha tiene pol√≠gono
          if (
            !cancha.poligono_coordenadas ||
            !Array.isArray(cancha.poligono_coordenadas)
          ) {
            console.log("‚ö†Ô∏è Esta cancha no tiene pol√≠gono definido");
            return;
          }

          // Crear GeoJSON del pol√≠gono
          const polygonGeoJSON = {
            type: "FeatureCollection",
            features: [
              {
                type: "Feature",
                geometry: {
                  type: "Polygon",
                  coordinates: [cancha.poligono_coordenadas],
                },
                properties: {
                  cancha_id: cancha.id,
                  cancha_nombre: cancha.nombre,
                  estado_actual_id: cancha.estado_actual_id || 1,
                  tipo: "cancha_area",
                },
              },
            ],
          };

          // Agregar fuente del pol√≠gono al mapa
          if (map.getSource("cancha-polygon")) {
            map.removeSource("cancha-polygon");
          }

          map.addSource("cancha-polygon", {
            type: "geojson",
            data: polygonGeoJSON,
          });

          // Determinar colores seg√∫n el estado
          const estadoId = cancha.estado_actual_id || 1;
          let fillColor = "#3b82f6"; // Default: Azul (Creada)
          let strokeColor = "#2563eb"; // Default: Azul oscuro

          switch (estadoId) {
            case 1: // Creada
              fillColor = "#3b82f6";
              strokeColor = "#2563eb";
              break;
            case 7: // En Espera
              fillColor = "#fbbf24";
              strokeColor = "#f59e0b";
              break;
            case 2: // En Proceso - ID 2
              fillColor = "#fbbf24";
              strokeColor = "#10b981";
              break;
            case 4: // Validada
              fillColor = "#10b981";
              strokeColor = "#fbbf24";
              break;
            case 8: // Rechazada, en Espera
              fillColor = "#ef4444";
              strokeColor = "#fbbf24";
              break;
            case 6: // Cerrada
              fillColor = "#10b981";
              strokeColor = "#059669";
              break;
          }

          // Agregar capas del pol√≠gono con colores din√°micos
          map.addLayer({
            id: "cancha-polygon-fill",
            type: "fill",
            source: "cancha-polygon",
            paint: {
              "fill-color": fillColor,
              "fill-opacity": 0.3,
            },
          });

          map.addLayer({
            id: "cancha-polygon-stroke",
            type: "line",
            source: "cancha-polygon",
            paint: {
              "line-color": strokeColor,
              "line-width": 3,
              "line-opacity": 0.8,
            },
          });

          // No hacer zoom al pol√≠gono individual - dejar que el filtro de muro maneje la vista
          console.log(
            "‚úÖ Pol√≠gono de cancha mostrado exitosamente - zoom manejado por filtro de muro",
          );
        } catch (error) {
          console.error("‚ùå Error al cargar pol√≠gono de cancha:", error);
          showError(
            "Error al cargar el √°rea de la cancha: " + (error as Error).message,
          );
        }
      }

      // NUEVA IMPLEMENTACI√ìN ELEGANTE DE REVANCHAS
      function mostrarRevanchasEnMapaElegante(geojsonData) {
        console.log(
          "üöÄ EJECUTANDO mostrarRevanchasEnMapaElegante (Versi√≥n H√≠brida Profesional)",
        );
        try {
          if (!map) return;

          // Limpiar capas anteriores primero
          ocultarRevanchasEnMapa();

          console.log(
            "üìä Mostrando revanchas (Dise√±o Elegante):",
            geojsonData.features.length,
          );

          // 1. Preparar datos (Colores y L√≠neas)
          const getColorByRevancha = (revancha) => {
            if (!revancha || revancha === 0) return "#94a3b8";
            if (revancha > 3.5) return "#10b981";
            if (revancha >= 3.0) return "#fbbf24";
            return "#ef4444";
          };

          const enrichedFeatures = geojsonData.features.map((feature) => ({
            ...feature,
            properties: {
              ...feature.properties,
              dynamic_color: getColorByRevancha(feature.properties.revancha),
            },
          }));

          // Calcular l√≠neas de conexi√≥n
          const getDistance = (coord1, coord2) => {
            const R = 6371000;
            const lat1 = (coord1[1] * Math.PI) / 180;
            const lat2 = (coord2[1] * Math.PI) / 180;
            const deltaLat = ((coord2[1] - coord1[1]) * Math.PI) / 180;
            const deltaLon = ((coord2[0] - coord1[0]) * Math.PI) / 180;
            const a =
              Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) +
              Math.cos(lat1) *
                Math.cos(lat2) *
                Math.sin(deltaLon / 2) *
                Math.sin(deltaLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
          };

          // Calculate bearing between two coordinates
          const getBearing = (coord1, coord2) => {
            const lat1 = (coord1[1] * Math.PI) / 180;
            const lat2 = (coord2[1] * Math.PI) / 180;
            const deltaLon = ((coord2[0] - coord1[0]) * Math.PI) / 180;

            const y = Math.sin(deltaLon) * Math.cos(lat2);
            const x =
              Math.cos(lat1) * Math.sin(lat2) -
              Math.sin(lat1) * Math.cos(lat2) * Math.cos(deltaLon);

            return (Math.atan2(y, x) * 180) / Math.PI;
          };

          // Generate perpendicular line coordinates
          const getPerpendicularLine = (point, bearing, length, direction) => {
            // direction: 1 for right (+90¬∞), -1 for left (-90¬∞)
            const perpBearing = bearing + 90 * direction;
            const lat = point[1];
            const lon = point[0];

            // Convert to radians
            const brng = (perpBearing * Math.PI) / 180;
            const latRad = (lat * Math.PI) / 180;
            const lonRad = (lon * Math.PI) / 180;

            // Calculate endpoint
            const R = 6371000; // Earth radius in meters
            const newLat = Math.asin(
              Math.sin(latRad) * Math.cos(length / R) +
                Math.cos(latRad) * Math.sin(length / R) * Math.cos(brng),
            );
            const newLon =
              lonRad +
              Math.atan2(
                Math.sin(brng) * Math.sin(length / R) * Math.cos(latRad),
                Math.cos(length / R) - Math.sin(latRad) * Math.sin(newLat),
              );

            return [
              point,
              [(newLon * 180) / Math.PI, (newLat * 180) / Math.PI],
            ];
          };

          // Get color for ancho value
          const getAnchoColor = (ancho) => {
            const val = parseFloat(ancho);
            if (val > 18) return "#10b981"; // Verde
            if (val >= 15) return "#eab308"; // Amarillo
            return "#ef4444"; // Rojo
          };

          const lineFeatures = [];
          const MAX_DISTANCE = 100;

          for (let i = 0; i < enrichedFeatures.length; i++) {
            const current = enrichedFeatures[i];
            for (let j = i + 1; j < enrichedFeatures.length; j++) {
              const next = enrichedFeatures[j];
              const distance = getDistance(
                current.geometry.coordinates,
                next.geometry.coordinates,
              );
              if (distance <= MAX_DISTANCE) {
                lineFeatures.push({
                  type: "Feature",
                  geometry: {
                    type: "LineString",
                    coordinates: [
                      current.geometry.coordinates,
                      next.geometry.coordinates,
                    ],
                  },
                  properties: {
                    from_color: current.properties.dynamic_color,
                    to_color: next.properties.dynamic_color,
                  },
                });
              }
            }
          }

          // Generate perpendicular width lines
          // Group PKs by wall
          const pksByWall = {
            Principal: [],
            Este: [],
            Oeste: [],
          };

          enrichedFeatures.forEach((feature) => {
            const muro = feature.properties.muro;
            if (pksByWall[muro]) {
              pksByWall[muro].push(feature);
            }
          });

          // Sort each wall by PK number
          Object.keys(pksByWall).forEach((wall) => {
            pksByWall[wall].sort((a, b) => {
              const pkA = parseFloat(a.properties.pk.replace("+", "."));
              const pkB = parseFloat(b.properties.pk.replace("+", "."));
              return pkA - pkB;
            });
          });

          console.log("üîç PKs by wall:", {
            Principal: pksByWall.Principal.length,
            Este: pksByWall.Este.length,
            Oeste: pksByWall.Oeste.length,
          });
          console.log(
            "Sample feature muro:",
            enrichedFeatures[0]?.properties?.muro,
          );

          // Generate perpendicular lines
          const widthLines = [];
          const lineLength = 33; // meters - 2/3 of original 50m

          Object.entries(pksByWall).forEach(([wall, features]) => {
            const direction = wall === "Oeste" ? -1 : 1; // Oeste left, Principal/Este right

            for (let i = 0; i < features.length; i++) {
              const current = features[i];
              let bearing;

              if (i < features.length - 1) {
                // Not the last point: use bearing to next point
                const next = features[i + 1];
                bearing = getBearing(
                  current.geometry.coordinates,
                  next.geometry.coordinates,
                );
              } else {
                // Last point: use bearing from previous segment
                if (i > 0) {
                  const prev = features[i - 1];
                  bearing = getBearing(
                    prev.geometry.coordinates,
                    current.geometry.coordinates,
                  );
                } else {
                  // Solo hay un punto, skip
                  continue;
                }
              }

              const lineCoords = getPerpendicularLine(
                current.geometry.coordinates,
                bearing,
                lineLength,
                direction,
              );

              widthLines.push({
                type: "Feature",
                geometry: {
                  type: "LineString",
                  coordinates: lineCoords,
                },
                properties: {
                  ancho: current.properties.ancho,
                  color: getAnchoColor(current.properties.ancho),
                  pk: current.properties.pk,
                  muro: wall,
                },
              });
            }
          });

          console.log("‚úÖ Width Lines Generated:", widthLines.length, "lines");
          console.log("Sample:", widthLines[0]);

          // 2. Agregar Sources
          map.addSource("revanchas-source", {
            type: "geojson",
            data: { type: "FeatureCollection", features: enrichedFeatures },
          });

          map.addSource("revanchas-lines", {
            type: "geojson",
            data: { type: "FeatureCollection", features: lineFeatures },
          });

          map.addSource("width-lines", {
            type: "geojson",
            data: { type: "FeatureCollection", features: widthLines },
          });

          // 3. Agregar Capas (Dise√±o Elegante)

          // L√≠neas de conexi√≥n (Sutiles)
          map.addLayer({
            id: "revanchas-connections",
            type: "line",
            source: "revanchas-lines",
            paint: {
              "line-color": ["get", "from_color"],
              "line-width": 1.5, // Visible pero fino
              "line-opacity": 0.4, // Recuperamos visibilidad
              "line-blur": 0.5, // Menos blur para definici√≥n
            },
          });

          // Width Lines (Ancho visualization)
          map.addLayer({
            id: "width-lines-layer",
            type: "line",
            source: "width-lines",
            paint: {
              "line-color": ["get", "color"],
              "line-width": 3,
              "line-opacity": 0.9,
            },
          });

          // Width Lines Pulse Layers (for sonar animation)
          const widthPulseLayers = [
            "width-pulse-1",
            "width-pulse-2",
            "width-pulse-3",
          ];
          widthPulseLayers.forEach((id) => {
            map.addLayer({
              id: id,
              type: "line",
              source: "width-lines",
              paint: {
                "line-color": ["get", "color"],
                "line-width": 3,
                "line-opacity": 0.3,
              },
            });
          });

          console.log("‚úÖ Width pulse layers created:", widthPulseLayers);

          // Capas de Pulso (4 capas id√©nticas para animaci√≥n)
          const pulseLayers = [
            "revanchas-pulse-1",
            "revanchas-pulse-2",
            "revanchas-pulse-3",
            "revanchas-pulse-4",
          ];
          pulseLayers.forEach((id) => {
            map.addLayer({
              id: id,
              type: "circle",
              source: "revanchas-source",
              paint: {
                "circle-radius": 0,
                "circle-color": ["get", "dynamic_color"], // Recuperamos relleno sutil
                "circle-stroke-color": ["get", "dynamic_color"],
                "circle-stroke-width": 1.5,
                "circle-stroke-opacity": 0,
                "circle-opacity": 0,
                "circle-blur": 0.5, // Un toque de suavidad (no neon)
              },
            });
          });

          // Glow Central (Posici√≥n real)
          map.addLayer({
            id: "revanchas-glow-inner",
            type: "circle",
            source: "revanchas-source",
            paint: {
              "circle-radius": [
                "interpolate",
                ["linear"],
                ["zoom"],
                12,
                4,
                16,
                8,
                20,
                16,
              ],
              "circle-color": ["get", "dynamic_color"],
              "circle-opacity": 0.9,
              "circle-blur": 0.3, // Suave pero definido
              // Borde eliminado por petici√≥n del usuario
            },
          });

          // Etiquetas
          map.addLayer({
            id: "revanchas-labels",
            type: "symbol",
            source: "revanchas-source",
            layout: {
              "text-field": ["get", "pk"],
              "text-font": ["Open Sans Bold", "Arial Unicode MS Bold"],
              "text-size": 11,
              "text-offset": [0, 1.2],
              "text-anchor": "top",
            },
            paint: {
              "text-color": "#ffffff",
              "text-halo-color": "rgba(0,0,0,0.7)",
              "text-halo-width": 1,
              "text-halo-blur": 0.5,
              "text-opacity": 0.9,
            },
            minzoom: 15,
          });

          // 4. Animaci√≥n Elegante
          let sonarPhase = 0;
          function animateElegantSonar() {
            if (!map.getLayer("revanchas-pulse-1")) return;

            sonarPhase = (sonarPhase + 0.005) % 1;

            // Radios invertidos: Peque√±os lejos (solo color), Grandes cerca (ondas expansivas)
            const maxRadiusStops = [15, 50, 100];

            pulseLayers.forEach((layerId, index) => {
              const layerPhase = (sonarPhase + index / pulseLayers.length) % 1;

              // Opacidad del borde (m√°s fuerte)
              const strokeOpacity = 0.8 * Math.pow(1 - layerPhase, 1.5);

              // Opacidad del relleno (muy sutil, para dar cuerpo)
              const fillOpacity = 0.2 * Math.pow(1 - layerPhase, 2);

              // Ancho del borde se mantiene elegante
              const strokeWidth = 2 * (1 - layerPhase * 0.5);

              const radiusExpression = [
                "interpolate",
                ["linear"],
                ["zoom"],
                10,
                0, // Zoom alejado: sin onda
                15,
                0, // Zoom medio-alejado: sin onda
                16,
                10 * layerPhase, // ~100m: empieza a aparecer
                17,
                30 * layerPhase, // ~50m: onda visible
                18,
                50 * layerPhase, // ~30m: onda moderada
                19,
                80 * layerPhase, // ~15m: onda grande
                20,
                120 * layerPhase, // Zoom m√°ximo: onda completa
              ];

              try {
                // Efecto Neon Suave: Solo relleno con blur, sin borde
                map.setPaintProperty(
                  layerId,
                  "circle-radius",
                  radiusExpression,
                );
                map.setPaintProperty(
                  layerId,
                  "circle-opacity",
                  0.8 * Math.pow(1 - layerPhase, 1.2),
                );
                map.setPaintProperty(layerId, "circle-blur", 0.1);
                map.setPaintProperty(layerId, "circle-stroke-width", 0);
                map.setPaintProperty(layerId, "circle-stroke-opacity", 0);
              } catch (e) {}
            });

            // Animar width lines (efecto sonar en l√≠neas)
            widthPulseLayers.forEach((layerId, index) => {
              const layerPhase =
                (sonarPhase + index / widthPulseLayers.length) % 1;

              // Opacidad que se desvanece m√°s lentamente
              const opacity = 0.8 * Math.pow(1 - layerPhase, 1.2);

              // Ancho que crece mucho m√°s - efecto sonar expandi√©ndose
              const widthGrowth = layerPhase * 8; // Crece hasta 8x el ancho original

              try {
                map.setPaintProperty(
                  layerId,
                  "line-width",
                  3 + widthGrowth, // Empieza en 3px y crece
                );
                map.setPaintProperty(layerId, "line-opacity", opacity);
              } catch (e) {}
            });

            requestAnimationFrame(animateElegantSonar);
          }
          animateElegantSonar();

          // 5. Interacci√≥n (Popup)
          map.on("click", "revanchas-glow-inner", (e) => {
            const feature = e.features[0];
            const props = feature.properties;

            const anchoValue = parseFloat(props.ancho);
            let anchoColor = "#10b981"; // Verde por defecto (> 18)
            if (anchoValue < 15) {
              anchoColor = "#ef4444"; // Rojo
            } else if (anchoValue >= 15 && anchoValue <= 18) {
              anchoColor = "#eab308"; // Amarillo
            }

            const html = `
              <div class="p-0 font-sans" style="min-width: 240px;">
                <!-- Header -->
                <div class="bg-slate-800 text-white p-3 rounded-t-lg">
                  <div class="flex items-center justify-between gap-2 mb-1">
                    <h3 class="font-semibold text-base m-0">PK ${props.pk}</h3>
                    <span class="text-xs text-slate-300">${props.muro} - Sector ${props.sector}</span>
                  </div>
                  ${props.fecha_medicion ? `<div class="text-xs text-slate-400">${props.fecha_medicion}</div>` : ""}
                </div>
                
                <!-- Body -->
                <div class="p-3 bg-white rounded-b-lg">
                   <div class="border-t border-slate-200 mb-3"></div>
                   
                   <div class="space-y-2 text-sm">
                      <div class="flex justify-between">
                        <span class="text-slate-600">Revancha</span>
                        <span><span class="font-bold" style="color: ${props.dynamic_color}">${props.revancha}</span> m</span>
                      </div>
                      <div class="flex justify-between">
                        <span class="text-slate-600">Ancho</span>
                        <span class="font-bold" style="color: ${anchoColor}">${props.ancho}m</span>
                      </div>
                      <div class="flex justify-between">
                        <span class="text-slate-600">Coronamiento</span>
                        <span class="font-bold text-slate-800">${props.coronamiento}m</span>
                      </div>
                      <div class="flex justify-between">
                        <span class="text-slate-600">Lama</span>
                        <span class="font-bold text-slate-800">${props.lama}m</span>
                      </div>
                   </div>
                </div>
              </div>
             `;

            new mapboxgl.Popup({ maxWidth: "340px", closeButton: false })
              .setLngLat(e.lngLat)
              .setHTML(html)
              .addTo(map);
          });

          // Cursor
          map.on(
            "mouseenter",
            "revanchas-glow-inner",
            () => (map.getCanvas().style.cursor = "pointer"),
          );
          map.on(
            "mouseleave",
            "revanchas-glow-inner",
            () => (map.getCanvas().style.cursor = ""),
          );

          // 6. Fit Bounds
          if (geojsonData.features.length > 0) {
            const bounds = new mapboxgl.LngLatBounds();
            geojsonData.features.forEach((f) =>
              bounds.extend(f.geometry.coordinates),
            );
            map.fitBounds(bounds, { padding: 80, maxZoom: 14, duration: 2000 });
          }
        } catch (e) {
          console.error("Error en revanchas elegantes:", e);
        }
      }

      // Inicializar cuando el DOM est√© listo
      if (document.readyState === "loading") {
        document.addEventListener("DOMContentLoaded", initializeMap);
      } else {
        initializeMap();
      }
    } catch (error) {
      console.error("Error loading Mapbox dependencies:", error);
      const errorElement = document.getElementById("error");
      if (errorElement) {
        errorElement.textContent = "Error al cargar dependencias del mapa";
        errorElement.style.display = "block";
      }
    }
  }

  // Inicializar mapbox
  initMapbox();
</script>
